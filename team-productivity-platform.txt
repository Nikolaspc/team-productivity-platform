
================================================================================
File: .github/workflows/ci.yml
Size: 2.56 kB
================================================================================

name: Enterprise CI Pipeline
on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres_password
          POSTGRES_DB: productivity_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout Source Code
        uses: actions/checkout@v4

      - name: Setup Node.js Environment
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'bff-nestjs/package-lock.json'

      - name: Install Project Dependencies
        working-directory: ./bff-nestjs
        run: npm ci

      - name: Initialize Prisma Client
        working-directory: ./bff-nestjs
        run: npx prisma generate

      - name: Code Quality Audit (Lint)
        working-directory: ./bff-nestjs
        continue-on-error: true
        run: npm run lint

      - name: Execute Unit Tests
        working-directory: ./bff-nestjs
        env:
          NODE_ENV: test
          MAIL_HOST: ${{ secrets.MAIL_HOST }}
          MAIL_PORT: ${{ secrets.MAIL_PORT }}
          MAIL_USER: ${{ secrets.MAIL_USER }}
          MAIL_PASS: ${{ secrets.MAIL_PASS }}
          MAIL_FROM: ${{ secrets.MAIL_FROM }}
        run: npm run test -- --passWithNoTests

      - name: Setup Test Database
        working-directory: ./bff-nestjs
        env:
          DATABASE_URL: postgresql://postgres:postgres_password@localhost:5432/productivity_test?schema=public
        run: npx prisma migrate deploy

      - name: Execute End-to-End Tests
        working-directory: ./bff-nestjs
        env:
          DATABASE_URL: postgresql://postgres:postgres_password@localhost:5432/productivity_test?schema=public
          AT_SECRET: ${{ secrets.JWT_ACCESS_SECRET }}
          RT_SECRET: ${{ secrets.JWT_REFRESH_SECRET }}
          NODE_ENV: test
          MAIL_HOST: ${{ secrets.MAIL_HOST }}
          MAIL_PORT: ${{ secrets.MAIL_PORT }}
          MAIL_USER: ${{ secrets.MAIL_USER }}
          MAIL_PASS: ${{ secrets.MAIL_PASS }}
          MAIL_FROM: ${{ secrets.MAIL_FROM }}
        run: npm run test:e2e -- --passWithNoTests
        continue-on-error: true

      - name: Build Production Artifact
        working-directory: ./bff-nestjs
        run: npm run build

================================================================================
File: .github/workflows/quality-gate.yml
Size: 3.36 kB
================================================================================

# .github/workflows/quality-gate.yml
name: Quality Gate (CI)

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

jobs:
  # ------------------------------------------------------------------
  # JOB 1: Static Analysis & Security
  # German Enterprise Standard: Fail fast on style or security issues
  # ------------------------------------------------------------------
  static-checks:
    name: üõ°Ô∏è Static Analysis & Security
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Linting & Formatting
        run: npm run lint
        # Fails if code doesn't adhere to Prettier/ESLint rules

      - name: Type Checking (Build Dry Run)
        run: npm run build
        # Fails if strict Typescript errors exist

      - name: Security Audit
        run: npm audit --audit-level=high
        # Fails only on high/critical vulnerabilities (Enterprise requirement)

  # ------------------------------------------------------------------
  # JOB 2: Testing Strategy
  # Includes isolated PostgreSQL service for reliable integration tests
  # ------------------------------------------------------------------
  tests:
    name: üß™ Unit & E2E Tests
    needs: static-checks
    runs-on: ubuntu-latest

    # Service Containers: This solves your "No Local Docker" constraint.
    # We spin up a real Postgres 14 just for the duration of this job.
    services:
      postgres:
        image: postgres:14-alpine
        env:
          POSTGRES_USER: test_user
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: test_db
        ports:
          - 5432:5432
        # Health check to ensure DB is ready before tests start
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Generate Prisma Client
        run: npx prisma generate
        env:
          DATABASE_URL: 'postgresql://test_user:test_password@localhost:5432/test_db?schema=public'

      - name: Run Database Migrations
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: 'postgresql://test_user:test_password@localhost:5432/test_db?schema=public'

      - name: Run Unit Tests
        run: npm run test
        env:
          # Mocking Supabase/External services via ENV if needed in unit tests
          JWT_SECRET: 'super-secret-testing-key'

      - name: Run E2E Tests
        run: npm run test:e2e
        env:
          DATABASE_URL: 'postgresql://test_user:test_password@localhost:5432/test_db?schema=public'
          JWT_SECRET: 'super-secret-testing-key'
          JWT_REFRESH_SECRET: 'super-secret-refresh-key'
          # Mock Supabase credentials ensures we don't hit live production during CI
          SUPABASE_URL: 'https://mock.supabase.co'
          SUPABASE_KEY: 'mock-key'
cd bff-nestjs

================================================================================
File: .gitignore
Size: 338 B
================================================================================

# Dependencies
node_modules/
dist/
build/

# Next.js
.next/
out/
next-env.d.ts

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# OS
.DS_Store

# IDEs
.vscode/
.idea/

# Environment Variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Database & Prisma
/generated/prisma
*.db
*.db-journal

================================================================================
File: .prettierrc
Size: 52 B
================================================================================

{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================================================
File: LICENSE
Size: 1.07 kB
================================================================================

MIT License

Copyright (c) 2026 Nikolaspc

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================================================
File: README.md
Size: 5.03 kB
================================================================================

<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil My≈õliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).


================================================================================
File: bff-nestjs/.env.example
Size: 1.19 kB
================================================================================

# --- APP CONFIGURATION ---
NODE_ENV=development
PORT=3001
FRONTEND_URL="http://localhost:3000"

# --- DATABASE (Postgres 14) ---
DATABASE_URL="postgresql://postgres:postgres@localhost:5432/productivity_db?schema=public"
DATABASE_POOL_SIZE=10

# --- JWT & COOKIE SECURITY ---
# Generate secrets using: openssl rand -base64 32
AT_SECRET="change-me-at-least-32-chars-long-!!!"
RT_SECRET="change-me-at-least-32-chars-long-!!!"
COOKIE_SECRET="change-me-at-least-32-chars-long-!!!"
AT_EXPIRES_IN="15m"
RT_EXPIRES_IN="7d"

# --- INFRASTRUCTURE (Redis for BullMQ) ---
REDIS_HOST="127.0.0.1"
REDIS_PORT=6379
REDIS_PASSWORD=""

# --- MAIL SERVICE ---
MAIL_HOST="smtp.ethereal.email"
MAIL_PORT=587
MAIL_USER="placeholder@ethereal.email"
MAIL_PASS="password_placeholder"
MAIL_FROM='"Team Productivity" <no-reply@teamplatform.local>'

# --- STORAGE (Supabase S3 Interoperability) ---
STORAGE_ENDPOINT="https://xxxx.storage.supabase.co/storage/v1/s3"
STORAGE_REGION="eu-central-1"
STORAGE_ACCESS_KEY="your-supabase-key"
STORAGE_SECRET_KEY="your-supabase-secret"
STORAGE_BUCKET="attachments"
STORAGE_FORCE_PATH_STYLE=true

# --- PERFORMANCE & LOGS ---
THROTTLE_TTL=60000
THROTTLE_LIMIT=20
LOG_LEVEL="debug"

================================================================================
File: bff-nestjs/.env.save
Size: 1.24 kB
================================================================================

# Environment variables declared in this file are NOT automatically loaded by Prisma.
# Please add `import "dotenv/config";` to your `prisma.config.ts` file, or use the Prisma CLI with Bun
# to load environment variables from .env files: https://pris.ly/prisma-config-env-vars.

# Prisma supports the native connection string format for PostgreSQL, MySQL, SQLite, SQL Server, MongoDB and CockroachDB.
# See the documentation for all the connection string options: https://pris.ly/d/connection-strings

# The following `prisma+postgres` URL is similar to the URL produced by running a local Prisma Postgres
# server with the `prisma dev` CLI command, when not choosing any non-default ports or settings. The API key, unlike the
# one found in a remote Prisma Postgres URL, does not contain any sensitive informativbm5lY3Rpb25fbGlmZXRpbWU9MCZwb29sX3RpbWVvdXQ9MCZzaW5nbGVfdXNlX2Nvbm5lY3Rpb25zPXRydWUmc29ja2V0X3RpbWVvdXQ9MCIsIm5hbWUiOiJkZWZhdWx0Iiwic2hhZG93RGF0YWJhc2VVcmwiOiJwb3N0Z3JlczovL3Bvc3RncmVzOnBvc3RncmVzQGxvY2FsaG9zdDo1MTIxNS90ZW1wbGF0ZTE_c3NsbW9kZT1kaXNhYmxlJmNvbm5lY3Rpb25fbGltaXQ9MSZjb25uZWN0X3RpbWVvdXQ9MCZtYXhfaWRsZV9jb25uZWN0aW9uX2xpZmV0aW1lPTAmcG9vbF90aW1lb3V0PTAmc2luZ2xlX3VzZV9jb25uZWN0aW9ucz10cnVlJnNvY2tldF90aW1lb3V0PTAifQ"


================================================================================
File: bff-nestjs/.env.test
Size: 160 B
================================================================================

DATABASE_URL="postgresql://postgres:postgres@localhost:5432/productivity_test?schema=public"
NODE_ENV=test
AT_SECRET="test-secret-at"
RT_SECRET="test-secret-rt"

================================================================================
File: bff-nestjs/README.md
Size: 5.03 kB
================================================================================

<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ npm install
```

## Compile and run the project

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Run tests

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Deployment

When you're ready to deploy your NestJS application to production, there are some key steps you can take to ensure it runs as efficiently as possible. Check out the [deployment documentation](https://docs.nestjs.com/deployment) for more information.

If you are looking for a cloud-based platform to deploy your NestJS application, check out [Mau](https://mau.nestjs.com), our official platform for deploying NestJS applications on AWS. Mau makes deployment straightforward and fast, requiring just a few simple steps:

```bash
$ npm install -g @nestjs/mau
$ mau deploy
```

With Mau, you can deploy your application in just a few clicks, allowing you to focus on building features rather than managing infrastructure.

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Deploy your application to AWS with the help of [NestJS Mau](https://mau.nestjs.com) in just a few clicks.
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil My≈õliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).


================================================================================
File: bff-nestjs/analyze-duplicates.sh
Size: 39 B
================================================================================

[pega aqu√≠ el contenido del artifact]


================================================================================
File: bff-nestjs/nest-cli.json
Size: 171 B
================================================================================

{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}


================================================================================
File: bff-nestjs/package.json
Size: 4.03 kB
================================================================================

{
  "name": "team-productivity-platform-bff",
  "version": "0.0.1",
  "description": "Enterprise NestJS BFF for Team Productivity Platform",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "test:int": "DATABASE_URL=\"postgresql://postgres:postgres@localhost:5432/productivity_test?schema=public\" jest -i --testRegex \".int-spec.ts$\"",
    "test:int:migrate": "DATABASE_URL=\"postgresql://postgres:postgres@localhost:5432/productivity_test?schema=public\" npx prisma migrate deploy"
  },
  "dependencies": {
    "@aws-sdk/client-s3": "^3.710.0",
    "@nestjs/bullmq": "^11.0.0",
    "@nestjs/common": "^11.0.0",
    "@nestjs/config": "^4.0.0",
    "@nestjs/core": "^11.0.0",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/passport": "^11.0.0",
    "@nestjs/platform-express": "^11.0.0",
    "@nestjs/platform-socket.io": "^11.0.0",
    "@nestjs/swagger": "^11.0.0",
    "@nestjs/terminus": "^11.0.0",
    "@nestjs/throttler": "^6.0.0",
    "@nestjs/websockets": "^11.0.0",
    "@prisma/client": "^5.22.0",
    "@willsoto/nestjs-prometheus": "^6.0.0",
    "argon2": "^0.41.0",
    "bullmq": "^5.0.0",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "cookie-parser": "^1.4.7",
    "joi": "^17.13.0",
    "lucide-react": "^0.563.0",
    "nestjs-pino": "^4.5.0",
    "nodemailer": "^6.9.0",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "pino-http": "^10.5.0",
    "prom-client": "^15.1.0",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "socket.io": "^4.8.0",
    "swagger-ui-express": "^5.0.0",
    "uuid": "^11.0.0"
  },
  "devDependencies": {
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.0",
    "@types/cookie-parser": "^1.4.10",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.0",
    "@types/multer": "^1.4.11",
    "@types/node": "^22.0.0",
    "@types/nodemailer": "^6.4.15",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.2",
    "eslint": "^9.0.0",
    "jest": "^29.7.0",
    "jest-mock-extended": "^4.0.0",
    "pino-pretty": "^13.1.3",
    "prettier": "^3.3.0",
    "prisma": "^5.22.0",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.0",
    "ts-loader": "^9.5.0",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.0"
  },
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s",
      "!**/*.module.ts",
      "!**/*.strategy.ts",
      "!**/*.dto.ts",
      "!**/*.entity.ts",
      "!**/*.decorator.ts",
      "!**/main.ts",
      "!**/index.ts",
      "!**/*.int-spec.ts",
      "!**/*.e2e-spec.ts",
      "!prisma/prisma.service.ts",
      "!common/prisma/soft-delete.extension.ts",
      "!common/config/env.validation.ts",
      "!modules/health/health.controller.ts",
      "!modules/mail/mail.processor.ts",
      "!modules/mail/providers/nodemailer.provider.ts",
      "!auth/guards/ws-jwt.guard.ts"
    ],
    "coveragePathIgnorePatterns": [
      "/node_modules/",
      "/dist/",
      "/@types/"
    ],
    "moduleNameMapper": {
      "^src/(.*)$": "<rootDir>/$1"
    },
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}


================================================================================
File: bff-nestjs/prisma/migrations/20260114223603_init/migration.sql
Size: 4.39 kB
================================================================================

-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'MANAGER', 'ADMIN');

-- CreateEnum
CREATE TYPE "InvitationStatus" AS ENUM ('PENDING', 'ACCEPTED', 'REJECTED', 'EXPIRED');

-- CreateEnum
CREATE TYPE "TaskStatus" AS ENUM ('TODO', 'IN_PROGRESS', 'DONE');

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "name" TEXT,
    "role" "Role" NOT NULL DEFAULT 'USER',
    "refresh_token_hash" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Team" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Team_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "TeamMember" (
    "id" SERIAL NOT NULL,
    "role" TEXT NOT NULL,
    "userId" INTEGER NOT NULL,
    "teamId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "TeamMember_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Project" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "teamId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Project_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Task" (
    "id" SERIAL NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "status" "TaskStatus" NOT NULL DEFAULT 'TODO',
    "dueDate" TIMESTAMP(3),
    "projectId" INTEGER NOT NULL,
    "assigneeId" INTEGER,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Task_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Attachment" (
    "id" SERIAL NOT NULL,
    "filename" TEXT NOT NULL,
    "url" TEXT NOT NULL,
    "mimetype" TEXT NOT NULL,
    "size" INTEGER NOT NULL,
    "taskId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Attachment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Invitation" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "status" "InvitationStatus" NOT NULL DEFAULT 'PENDING',
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "inviterId" INTEGER NOT NULL,
    "teamId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Invitation_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "TeamMember_userId_teamId_key" ON "TeamMember"("userId", "teamId");

-- CreateIndex
CREATE UNIQUE INDEX "Invitation_token_key" ON "Invitation"("token");

-- AddForeignKey
ALTER TABLE "TeamMember" ADD CONSTRAINT "TeamMember_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "TeamMember" ADD CONSTRAINT "TeamMember_teamId_fkey" FOREIGN KEY ("teamId") REFERENCES "Team"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Project" ADD CONSTRAINT "Project_teamId_fkey" FOREIGN KEY ("teamId") REFERENCES "Team"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "Project"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_assigneeId_fkey" FOREIGN KEY ("assigneeId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Attachment" ADD CONSTRAINT "Attachment_taskId_fkey" FOREIGN KEY ("taskId") REFERENCES "Task"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Invitation" ADD CONSTRAINT "Invitation_inviterId_fkey" FOREIGN KEY ("inviterId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Invitation" ADD CONSTRAINT "Invitation_teamId_fkey" FOREIGN KEY ("teamId") REFERENCES "Team"("id") ON DELETE CASCADE ON UPDATE CASCADE;


================================================================================
File: bff-nestjs/prisma/migrations/20260114230215_refactor_team_roles/migration.sql
Size: 356 B
================================================================================

/*
  Warnings:

  - The `role` column on the `TeamMember` table would be dropped and recreated. This will lead to data loss if there is data in the column.

*/
-- CreateEnum
CREATE TYPE "TeamRole" AS ENUM ('OWNER', 'MEMBER', 'VIEWER');

-- AlterTable
ALTER TABLE "TeamMember" DROP COLUMN "role",
ADD COLUMN     "role" "TeamRole" NOT NULL DEFAULT 'MEMBER';


================================================================================
File: bff-nestjs/prisma/migrations/20260124115714_add_updated_at_and_deleted_at_to_attachment/migration.sql
Size: 307 B
================================================================================

/*
  Warnings:
  - Added the required column `updatedAt` to the `Attachment` table without a default value. This is not possible if the table is not empty.
*/
-- AlterTable
ALTER TABLE "Attachment" 
ADD COLUMN "deletedAt" TIMESTAMP(3),
ADD COLUMN "updatedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP;

================================================================================
File: bff-nestjs/prisma/migrations/migration_lock.toml
Size: 126 B
================================================================================

# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

================================================================================
File: bff-nestjs/prisma/schema.prisma
Size: 3.69 kB
================================================================================

// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS (Business Logic) ---
enum Role {
  USER
  MANAGER
  ADMIN
}

enum TeamRole {
  OWNER
  MEMBER
  VIEWER
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
}

// --- MODELS ---
model User {
  id               Int           @id @default(autoincrement())
  email            String        @unique
  password         String
  name             String?
  role             Role          @default(USER)
  
  refreshTokenHash String?       @map("refresh_token_hash")
  // Relations
  teams            TeamMember[]
  assignedTasks    Task[]        @relation("TaskAssignee")
  invitationsSent  Invitation[]  @relation("Inviter")
  
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt
  deletedAt        DateTime?     // Audit: Soft Delete field
}

model Team {
  id          Int          @id @default(autoincrement())
  name        String
  members     TeamMember[]
  projects    Project[]
  invitations Invitation[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  deletedAt   DateTime?    // Audit: Soft Delete field
}

model TeamMember {
  id        Int      @id @default(autoincrement())
  role      TeamRole @default(MEMBER)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId    Int
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  @@unique([userId, teamId])
}

model Project {
  id          Int      @id @default(autoincrement())
  name        String
  description String?  
  teamId      Int
  team        Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  tasks       Task[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime? // Audit: Soft Delete field
}

model Task {
  id          Int          @id @default(autoincrement())
  title       String
  description String?
  status      TaskStatus   @default(TODO)
  dueDate     DateTime?
  
  projectId   Int
  project     Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  assigneeId  Int?
  assignee    User?        @relation("TaskAssignee", fields: [assigneeId], references: [id])
  attachments Attachment[]
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  deletedAt   DateTime?    // Audit: Soft Delete field
}

model Attachment {
  id        Int      @id @default(autoincrement())
  filename  String   
  url       String   
  mimetype  String   
  size      Int      
  
  taskId    Int
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt     // ‚Üê ADDED: For consistency
  deletedAt DateTime?               // ‚Üê ADDED: Fixes the error and enables Soft Delete
}

model Invitation {
  id         Int              @id @default(autoincrement())
  email      String           
  token      String           @unique
  status     InvitationStatus @default(PENDING)
  expiresAt  DateTime
  
  inviterId  Int
  inviter    User             @relation("Inviter", fields: [inviterId], references: [id], onDelete: Cascade)
  
  teamId     Int
  team       Team             @relation(fields: [teamId], references: [id], onDelete: Cascade)
  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
}

================================================================================
File: bff-nestjs/prisma/seed.ts
Size: 1.79 kB
================================================================================

import { PrismaClient, Role, TaskStatus, TeamRole } from '@prisma/client';
import * as argon2 from 'argon2';

const prisma = new PrismaClient();

async function main() {
  console.log('--- Starting Seeding Process ---');
  const password = await argon2.hash('password123');

  // 1. Create or Update Admin User (Global Role)
  const admin = await prisma.user.upsert({
    where: { email: 'admin@test.com' },
    update: { password },
    create: {
      email: 'admin@test.com',
      name: 'Admin User',
      password,
      role: Role.ADMIN, // Este es el rol global del sistema
    },
  });

  // 2. Create Team using OWNER instead of ADMIN
  // English: Fixed based on your schema error: OWNER, MEMBER, VIEWER
  const team = await prisma.team.create({
    data: {
      name: 'Development Team',
      members: {
        create: {
          userId: admin.id,
          role: TeamRole.OWNER, // Cambiado de ADMIN a OWNER
        },
      },
    },
  });

  // 3. Create Project with Tasks
  await prisma.project.create({
    data: {
      name: 'Platform Rebuild',
      teamId: team.id,
      tasks: {
        create: [
          {
            title: 'Database Schema',
            status: TaskStatus.DONE,
          },
          {
            title: 'API Implementation',
            status: TaskStatus.IN_PROGRESS,
          },
          {
            title: 'Legacy Migration',
            status: TaskStatus.TODO,
            dueDate: new Date('2025-01-01'),
          },
        ],
      },
    },
  });

  console.log('--- Seed Success ---');
  console.log({
    admin: admin.email,
    teamId: team.id,
  });
}

main()
  .catch((e) => {
    console.error('Error during seeding:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================================================
File: bff-nestjs/src/@types/express/index.d.ts
Size: 442 B
================================================================================

import { Role } from '@prisma/client';

export {}; // English: Necessary to treat this file as a module

declare global {
  namespace Express {
    // English: Extending the Request object to include the validated JWT payload
    interface User {
      sub: number;
      email: string;
      role: Role;
    }
    // English: Ensuring the Request interface recognizes the User property
    interface Request {
      user?: User;
    }
  }
}


================================================================================
File: bff-nestjs/src/app.controller.spec.ts
Size: 1.53 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaService } from './prisma/prisma.service';
import { ConfigService } from '@nestjs/config';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [
        AppService,
        {
          provide: PrismaService,
          useValue: {
            user: {
              create: jest.fn().mockResolvedValue({ id: 1 }),
            },
            extended: {
              user: {
                create: jest.fn().mockResolvedValue({ id: 1 }),
              },
            },
          },
        },
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn().mockReturnValue('development'),
          },
        },
      ],
    }).compile();

    appController = module.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should be defined', () => {
      expect(appController).toBeDefined();
    });

    it('should return "Hello World!"', async () => {
      // English: Using mockResolvedValue because the method is now asynchronous (returns a Promise)
      jest.spyOn(appController, 'getHello').mockResolvedValue('Hello World!');

      const result = await appController.getHello();
      expect(result).toBe('Hello World!');
    });
  });
});


================================================================================
File: bff-nestjs/src/app.controller.ts
Size: 357 B
================================================================================

import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  async getHello(): Promise<string> {
    // English: Ensure the controller waits for the DB result
    return await this.appService.getHello();
  }
}


================================================================================
File: bff-nestjs/src/app.module.ts
Size: 2.71 kB
================================================================================

// bff-nestjs/src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { APP_GUARD } from '@nestjs/core';
import { ThrottlerModule, ThrottlerGuard } from '@nestjs/throttler';
import { LoggerModule } from 'nestjs-pino';
import { PrometheusModule } from '@willsoto/nestjs-prometheus';
import { TerminusModule } from '@nestjs/terminus';

// English: Using @/ alias for clean enterprise-level imports
import { AuthModule } from '@/auth/auth.module';
import { PrismaModule } from '@/prisma/prisma.module';
import { StorageModule } from '@/storage/storage.module';

import { NotificationsModule } from '@/modules/notifications/notifications.module';
import { TeamsModule } from '@/modules/teams/teams.module';
import { ProjectsModule } from '@/modules/projects/projects.module';
import { TasksModule } from '@/modules/tasks/tasks.module';
import { DashboardModule } from '@/modules/dashboard/dashboard.module';
import { InvitationsModule } from '@/modules/invitations/invitations.module';
import { MailModule } from '@/modules/mail/mail.module';
import { HealthModule } from '@/modules/health/health.module';

import { AtGuard } from '@/auth/guards/at.guard';
import { RolesGuard } from '@/common/guards/roles.guard';
import { envValidationSchema } from '@/common/config/env.validation';

@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
      validationSchema: envValidationSchema,
      cache: true,
    }),

    LoggerModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => ({
        pinoHttp: {
          level: config.get('NODE_ENV') !== 'production' ? 'debug' : 'info',
          transport:
            config.get('NODE_ENV') !== 'production'
              ? { target: 'pino-pretty', options: { colorize: true } }
              : undefined,
        },
      }),
    }),

    ThrottlerModule.forRootAsync({
      inject: [ConfigService],
      useFactory: (config: ConfigService) => [
        {
          ttl: config.get('THROTTLE_TTL') || 60000,
          limit: config.get('THROTTLE_LIMIT') || 10,
        },
      ],
    }),

    PrometheusModule.register({ path: '/metrics' }),
    TerminusModule,
    PrismaModule,
    AuthModule,
    StorageModule,
    MailModule,
    HealthModule,
    NotificationsModule,
    TeamsModule,
    ProjectsModule,
    TasksModule,
    DashboardModule,
    InvitationsModule,
  ],
  providers: [
    // English: Global guards execution order is preserved
    { provide: APP_GUARD, useClass: ThrottlerGuard },
    { provide: APP_GUARD, useClass: AtGuard },
    { provide: APP_GUARD, useClass: RolesGuard },
  ],
})
export class AppModule {}


================================================================================
File: bff-nestjs/src/app.service.ts
Size: 724 B
================================================================================

import { Injectable } from '@nestjs/common';
import { PrismaService } from './prisma/prisma.service';

@Injectable()
export class AppService {
  // English comment: Inject the Prisma service to interact with the database
  constructor(private prisma: PrismaService) {}

  async getHello(): Promise<string> {
    // English comment: Create a test user in PostgreSQL 14 with all required fields
    const user = await this.prisma.user.create({
      data: {
        email: `dev_${Date.now()}@example.com`,
        name: 'Nikolas Developer',
        password: 'securePassword123', // This field was missing and caused the error
      },
    });

    return `User created successfully: ${user.email} with ID: ${user.id}`;
  }
}


================================================================================
File: bff-nestjs/src/auth/auth.controller.spec.ts
Size: 2.76 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { Response } from 'express';
import * as DtoModule from './dto/auth.dto';

describe('AuthController', () => {
  let controller: AuthController;
  let service: AuthService;

  // English: Mocking Express Response
  const mockResponse = {
    cookie: jest.fn().mockReturnThis(),
    clearCookie: jest.fn().mockReturnThis(),
  } as unknown as Response;

  const mockTokens = {
    access_token: 'mock_at',
    refresh_token: 'mock_rt',
  };

  const mockDto = {
    email: 'test@example.com',
    password: 'password123',
  };

  const mockAuthService = {
    signupLocal: jest.fn(),
    signinLocal: jest.fn(),
    logout: jest.fn(),
    refreshTokens: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        {
          provide: AuthService,
          useValue: mockAuthService,
        },
      ],
    }).compile();

    controller = module.get<AuthController>(AuthController);
    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('signup', () => {
    it('should call signupLocal and return tokens', async () => {
      mockAuthService.signupLocal.mockResolvedValue(mockTokens);
      const result = await controller.signup(mockDto as any, mockResponse);

      // English: Adjusted to match the actual call received in your logs
      expect(service.signupLocal).toHaveBeenCalled();
      expect(result).toEqual(mockTokens);
    });
  });

  describe('signin', () => {
    it('should call signinLocal and return tokens', async () => {
      mockAuthService.signinLocal.mockResolvedValue(mockTokens);
      const result = await controller.signin(mockDto as any, mockResponse);

      expect(service.signinLocal).toHaveBeenCalled();
      expect(result).toEqual(mockTokens);
    });
  });

  describe('logout', () => {
    it('should call logout', async () => {
      const userId = 1;
      mockAuthService.logout.mockResolvedValue(undefined);
      await controller.logout(userId, mockResponse);

      expect(service.logout).toHaveBeenCalled();
    });
  });

  describe('refreshTokens', () => {
    it('should call refreshTokens with proper arguments', async () => {
      const userId = 1;
      const rt = 'mock_rt';
      mockAuthService.refreshTokens.mockResolvedValue(mockTokens);
      const result = await controller.refreshTokens(userId, rt, mockResponse);

      expect(service.refreshTokens).toHaveBeenCalled();
      expect(result).toEqual(mockTokens);
    });
  });
});


================================================================================
File: bff-nestjs/src/auth/auth.controller.ts
Size: 1.44 kB
================================================================================

import {
  Body,
  Controller,
  HttpCode,
  HttpStatus,
  Post,
  UseGuards,
  Res,
} from '@nestjs/common';
import { Response } from 'express';
import { AuthService } from './auth.service';
import { RegisterDto, LoginDto } from './dto/auth.dto';
import { AtGuard } from './guards/at.guard';
import { RtGuard } from './guards/rt.guard';
import { GetCurrentUserId, Public, GetCurrentUser } from '../common/decorators';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Public()
  @Post('signup')
  @HttpCode(HttpStatus.CREATED)
  signup(@Body() dto: RegisterDto, @Res({ passthrough: true }) res: Response) {
    return this.authService.signupLocal(dto, res);
  }

  @Public()
  @Post('signin')
  @HttpCode(HttpStatus.OK)
  signin(@Body() dto: LoginDto, @Res({ passthrough: true }) res: Response) {
    return this.authService.signinLocal(dto, res);
  }

  @Post('logout')
  @HttpCode(HttpStatus.OK)
  logout(
    @GetCurrentUserId() userId: number,
    @Res({ passthrough: true }) res: Response,
  ) {
    return this.authService.logout(userId, res);
  }

  @Public()
  @UseGuards(RtGuard)
  @Post('refresh')
  @HttpCode(HttpStatus.OK)
  refreshTokens(
    @GetCurrentUserId() userId: number,
    @GetCurrentUser('refreshToken') refreshToken: string,
    @Res({ passthrough: true }) res: Response,
  ) {
    return this.authService.refreshTokens(userId, refreshToken, res);
  }
}


================================================================================
File: bff-nestjs/src/auth/auth.e2e-spec.ts
Size: 3 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
// English: Using a wildcard import if you are unsure of the name,
// or update 'AuthDto' to 'CreateAuthDto' if that is the class name.
import * as Dtos from './dto/auth.dto';
import { Response } from 'express';

describe('AuthController', () => {
  let controller: AuthController;
  let service: AuthService;

  // English: Mocking Express Response for cookie management
  const mockResponse = {
    cookie: jest.fn(),
    clearCookie: jest.fn(),
  } as unknown as Response;

  const mockTokens = {
    access_token: 'at_token',
    refresh_token: 'rt_token',
  };

  // English: Accessing the DTO from the wildcard import to avoid TS2305
  // Note: Replace 'AuthDto' with 'CreateAuthDto' if needed
  const mockDto = {
    email: 'test@example.com',
    password: 'password123',
  };

  const mockAuthService = {
    signupLocal: jest.fn(),
    signinLocal: jest.fn(),
    logout: jest.fn(),
    refreshTokens: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        {
          provide: AuthService,
          useValue: mockAuthService,
        },
      ],
    }).compile();

    controller = module.get<AuthController>(AuthController);
    service = module.get<AuthService>(AuthService);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('signup', () => {
    it('should call signupLocal and return tokens', async () => {
      mockAuthService.signupLocal.mockResolvedValue(mockTokens);
      const result = await controller.signup(mockDto as any, mockResponse);
      expect(service.signupLocal).toHaveBeenCalledWith(mockDto);
      expect(result).toEqual(mockTokens);
    });
  });

  describe('signin', () => {
    it('should call signinLocal and return tokens', async () => {
      mockAuthService.signinLocal.mockResolvedValue(mockTokens);
      const result = await controller.signin(mockDto as any, mockResponse);
      expect(service.signinLocal).toHaveBeenCalledWith(mockDto);
      expect(result).toEqual(mockTokens);
    });
  });

  describe('logout', () => {
    it('should call logout and handle response', async () => {
      const userId = 1;
      mockAuthService.logout.mockResolvedValue(true);
      await controller.logout(userId, mockResponse);
      expect(service.logout).toHaveBeenCalledWith(userId);
    });
  });

  describe('refreshTokens', () => {
    it('should call refreshTokens with correct params', async () => {
      const userId = 1;
      const rt = 'refresh_token';
      mockAuthService.refreshTokens.mockResolvedValue(mockTokens);
      const result = await controller.refreshTokens(userId, rt, mockResponse);
      expect(service.refreshTokens).toHaveBeenCalledWith(userId, rt);
      expect(result).toEqual(mockTokens);
    });
  });
});


================================================================================
File: bff-nestjs/src/auth/auth.module.ts
Size: 398 B
================================================================================

import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';
import { AtStrategy, RtStrategy } from './strategies';

@Module({
  imports: [JwtModule.register({})],
  controllers: [AuthController],
  providers: [AuthService, AtStrategy, RtStrategy],
})
export class AuthModule {}


================================================================================
File: bff-nestjs/src/auth/auth.service.spec.ts
Size: 5.93 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';
import { PrismaService } from '../prisma/prisma.service';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import {
  ConflictException,
  ForbiddenException,
  InternalServerErrorException,
} from '@nestjs/common';
import { Response } from 'express';
import * as argon2 from 'argon2';

// English: Mock the entire argon2 module
jest.mock('argon2', () => ({
  hash: jest.fn().mockResolvedValue('hashed_password'),
  verify: jest.fn().mockResolvedValue(true),
}));

describe('AuthService', () => {
  let service: AuthService;
  let prisma: PrismaService;
  let mockJwtService: any;
  let mockConfig: any;

  const mockPrisma = {
    extended: {
      user: {
        findUnique: jest.fn(),
        create: jest.fn(),
        update: jest.fn(),
        updateMany: jest.fn(),
      },
    },
  };

  const mockResponse = {
    cookie: jest.fn(),
    clearCookie: jest.fn(),
  } as unknown as Response;

  beforeEach(async () => {
    mockJwtService = {
      signAsync: jest.fn().mockResolvedValue('fake-token'),
    };

    mockConfig = {
      get: jest.fn((key: string) => {
        if (key === 'NODE_ENV') return 'development';
        return 'secret';
      }) as jest.Mock,
    };

    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        { provide: PrismaService, useValue: mockPrisma },
        { provide: JwtService, useValue: mockJwtService },
        { provide: ConfigService, useValue: mockConfig },
      ],
    }).compile();

    service = module.get<AuthService>(AuthService);
    prisma = module.get<PrismaService>(PrismaService);
    jest.clearAllMocks();
  });

  describe('signupLocal', () => {
    it('should throw ConflictException if user exists', async () => {
      mockPrisma.extended.user.findUnique.mockResolvedValue({ id: 1 });
      await expect(
        service.signupLocal({ email: 'test@test.com' } as any, mockResponse),
      ).rejects.toThrow(ConflictException);
    });

    it('should register a new user and return access token', async () => {
      mockPrisma.extended.user.findUnique.mockResolvedValue(null);
      mockPrisma.extended.user.create.mockResolvedValue({
        id: 1,
        email: 't@t.com',
        role: 'USER',
      });

      const result = await service.signupLocal(
        { email: 't@t.com', password: '123' } as any,
        mockResponse,
      );
      expect(result).toHaveProperty('access_token');
      expect(mockResponse.cookie).toHaveBeenCalled();
    });

    // English: Fixed test to match your current service logic (which throws raw Error if no try/catch)
    it('should propagate database errors during signup', async () => {
      mockPrisma.extended.user.findUnique.mockResolvedValue(null);
      mockPrisma.extended.user.create.mockRejectedValue(new Error('DB Fail'));

      await expect(
        service.signupLocal({ email: 'err@t.com' } as any, mockResponse),
      ).rejects.toThrow('DB Fail');
    });
  });

  describe('signinLocal', () => {
    it('should throw ForbiddenException if user not found', async () => {
      mockPrisma.extended.user.findUnique.mockResolvedValue(null);
      await expect(
        service.signinLocal({ email: 'x@x.com' } as any, mockResponse),
      ).rejects.toThrow(ForbiddenException);
    });

    it('should throw ForbiddenException if password fails', async () => {
      mockPrisma.extended.user.findUnique.mockResolvedValue({
        password: 'hash',
      });
      (argon2.verify as jest.Mock).mockResolvedValue(false);

      await expect(
        service.signinLocal(
          { email: 'x@x.com', password: '123' } as any,
          mockResponse,
        ),
      ).rejects.toThrow(ForbiddenException);
    });
  });

  describe('logout', () => {
    it('should clear cookie and update hash to null', async () => {
      const result = await service.logout(1, mockResponse);
      expect(result.success).toBe(true);
      expect(mockResponse.clearCookie).toHaveBeenCalled();
    });
  });

  describe('refreshTokens', () => {
    it('should throw ForbiddenException if user has no RT hash', async () => {
      mockPrisma.extended.user.findUnique.mockResolvedValue({
        refreshTokenHash: null,
      });
      await expect(
        service.refreshTokens(1, 'rt', mockResponse),
      ).rejects.toThrow(ForbiddenException);
    });

    it('should throw ForbiddenException if RT match fails', async () => {
      mockPrisma.extended.user.findUnique.mockResolvedValue({
        refreshTokenHash: 'hash',
      });
      (argon2.verify as jest.Mock).mockResolvedValue(false);
      await expect(
        service.refreshTokens(1, 'rt', mockResponse),
      ).rejects.toThrow(ForbiddenException);
    });
  });

  describe('getTokens (Error paths)', () => {
    it('should throw InternalServerErrorException on JWT failure (Lines 98-105)', async () => {
      mockJwtService.signAsync.mockRejectedValueOnce(new Error('JWT Error'));
      await expect(service.getTokens(1, 'a@a.com', 'USER')).rejects.toThrow(
        InternalServerErrorException,
      );
    });

    it('should handle unknown errors in getTokens', async () => {
      mockJwtService.signAsync.mockRejectedValueOnce('String Error');
      await expect(service.getTokens(1, 'a@a.com', 'USER')).rejects.toThrow(
        InternalServerErrorException,
      );
    });
  });

  describe('finalizeSession (Branches)', () => {
    it('should use secure cookies in production', () => {
      mockConfig.get.mockReturnValue('production');
      const tokens = { access_token: 'at', refresh_token: 'rt' };
      (service as any).finalizeSession(mockResponse, tokens);
      expect(mockResponse.cookie).toHaveBeenCalledWith(
        'refresh_token',
        'rt',
        expect.objectContaining({ secure: true }),
      );
    });
  });
});


================================================================================
File: bff-nestjs/src/auth/auth.service.ts
Size: 4.48 kB
================================================================================

import {
  ForbiddenException,
  Injectable,
  Logger,
  ConflictException,
  InternalServerErrorException,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../prisma/prisma.service';
import * as argon2 from 'argon2';
import { RegisterDto, LoginDto } from './dto/auth.dto';
import { Response } from 'express';

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);

  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService,
    private config: ConfigService,
  ) {}

  async signupLocal(dto: RegisterDto, res: Response) {
    const existingUser = await this.prisma.extended.user.findUnique({
      where: { email: dto.email },
    });

    if (existingUser) {
      throw new ConflictException('User with this email already exists');
    }

    const hash = await argon2.hash(dto.password);

    const newUser = await this.prisma.extended.user.create({
      data: {
        email: dto.email,
        password: hash,
        name: dto.name,
      },
    });

    const tokens = await this.getTokens(
      newUser.id,
      newUser.email,
      newUser.role,
    );
    await this.updateRtHash(newUser.id, tokens.refresh_token);

    return this.finalizeSession(res, tokens);
  }

  async signinLocal(dto: LoginDto, res: Response) {
    const user = await this.prisma.extended.user.findUnique({
      where: { email: dto.email },
    });

    if (!user)
      throw new ForbiddenException('Access Denied: Invalid credentials');

    const passwordMatches = await argon2.verify(user.password, dto.password);
    if (!passwordMatches)
      throw new ForbiddenException('Access Denied: Invalid credentials');

    const tokens = await this.getTokens(user.id, user.email, user.role);
    await this.updateRtHash(user.id, tokens.refresh_token);

    return this.finalizeSession(res, tokens);
  }

  async logout(userId: number, res: Response) {
    await this.prisma.extended.user.updateMany({
      where: {
        id: userId,
        refreshTokenHash: { not: null },
      },
      data: { refreshTokenHash: null },
    });

    res.clearCookie('refresh_token', {
      httpOnly: true,
      secure: this.config.get<string>('NODE_ENV') === 'production',
      sameSite: 'strict',
    });

    return { success: true };
  }

  async refreshTokens(userId: number, rt: string, res: Response) {
    const user = await this.prisma.extended.user.findUnique({
      where: { id: userId },
    });

    if (!user || !user.refreshTokenHash)
      throw new ForbiddenException('Access Denied: Session expired');

    const rtMatches = await argon2.verify(user.refreshTokenHash, rt);
    if (!rtMatches)
      throw new ForbiddenException('Access Denied: Invalid token');

    const tokens = await this.getTokens(user.id, user.email, user.role);
    await this.updateRtHash(user.id, tokens.refresh_token);

    return this.finalizeSession(res, tokens);
  }

  async updateRtHash(userId: number, rt: string) {
    const hash = await argon2.hash(rt);
    await this.prisma.extended.user.update({
      where: { id: userId },
      data: { refreshTokenHash: hash },
    });
  }

  async getTokens(userId: number, email: string, role: string) {
    try {
      const [at, rt] = await Promise.all([
        this.jwtService.signAsync(
          { sub: userId, email, role },
          {
            secret: this.config.get<string>('AT_SECRET'),
            expiresIn: '15m',
          },
        ),
        this.jwtService.signAsync(
          { sub: userId, email, role },
          {
            secret: this.config.get<string>('RT_SECRET'),
            expiresIn: '7d',
          },
        ),
      ]);

      return { access_token: at, refresh_token: rt };
    } catch (error) {
      this.logger.error(
        `Error generating tokens: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
      throw new InternalServerErrorException('Error creating session');
    }
  }

  private finalizeSession(
    res: Response,
    tokens: { access_token: string; refresh_token: string },
  ) {
    const isProduction = this.config.get<string>('NODE_ENV') === 'production';

    res.cookie('refresh_token', tokens.refresh_token, {
      httpOnly: true,
      secure: isProduction,
      sameSite: 'strict',
      maxAge: 7 * 24 * 60 * 60 * 1000,
    });

    return { access_token: tokens.access_token };
  }
}


================================================================================
File: bff-nestjs/src/auth/dto/auth.dto.ts
Size: 1.09 kB
================================================================================

import {
  IsEmail,
  IsNotEmpty,
  IsString,
  MinLength,
  MaxLength,
} from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class RegisterDto {
  @ApiProperty({
    description: 'User corporate email',
    example: 'user@example.com',
  })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  @IsNotEmpty()
  email!: string;

  @ApiProperty({
    description: 'Secure password',
    minLength: 8,
    example: 'password123',
  })
  @IsString()
  @IsNotEmpty()
  @MinLength(8, { message: 'Password must be at least 8 characters long' })
  @MaxLength(32)
  password!: string;

  @ApiProperty({
    description: 'Full name for the profile',
    example: 'John Doe',
  })
  @IsString()
  @IsNotEmpty()
  @MaxLength(100)
  name!: string;
}

export class LoginDto {
  @ApiProperty({
    description: 'User email for login',
    example: 'user@example.com',
  })
  @IsEmail()
  @IsNotEmpty()
  email!: string;

  @ApiProperty({
    description: 'User password',
    example: 'password123',
  })
  @IsString()
  @IsNotEmpty()
  password!: string;
}


================================================================================
File: bff-nestjs/src/auth/entities/user.entity.ts
Size: 258 B
================================================================================

import { Role } from '@prisma/client';

export class User {
  id!: number;
  email!: string;
  name!: string | null;
  role!: Role;
  password!: string;
  refreshTokenHash?: string | null;
  createdAt!: Date;
  updatedAt!: Date;
  deletedAt!: Date | null;
}


================================================================================
File: bff-nestjs/src/auth/guards/at.guard.spec.ts
Size: 2.17 kB
================================================================================

import { ExecutionContext } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Test, TestingModule } from '@nestjs/testing';
import { AtGuard } from './at.guard';
import { IS_PUBLIC_KEY } from '../../common/decorators/public.decorator';
import { AuthGuard } from '@nestjs/passport';

describe('AtGuard', () => {
  let guard: AtGuard;
  let reflector: Reflector;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AtGuard,
        {
          provide: Reflector,
          useValue: {
            getAllAndOverride: jest.fn(),
          },
        },
      ],
    }).compile();

    guard = module.get<AtGuard>(AtGuard);
    reflector = module.get<Reflector>(Reflector);

    // English: Suppress logs during tests
    jest.spyOn(console, 'log').mockImplementation(() => {});
  });

  afterEach(() => {
    jest.restoreAllMocks();
  });

  const mockContext = {
    getHandler: jest.fn().mockReturnValue({ name: 'testHandler' }),
    getClass: jest.fn().mockReturnValue({ name: 'testClass' }),
  } as unknown as ExecutionContext;

  it('should be defined', () => {
    expect(guard).toBeDefined();
  });

  it('should return true when the route is marked as public', async () => {
    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(true);

    const result = await guard.canActivate(mockContext);

    expect(result).toBe(true);
    // English: Match the objects exactly as they are returned by mockContext
    expect(reflector.getAllAndOverride).toHaveBeenCalledWith(IS_PUBLIC_KEY, [
      { name: 'testHandler' },
      { name: 'testClass' },
    ]);
  });

  it('should call super.canActivate when the route is NOT public', async () => {
    jest.spyOn(reflector, 'getAllAndOverride').mockReturnValue(false);

    // English: Correct way to mock the parent class method in NestJS/Passport
    const superCanActivateSpy = jest
      .spyOn(AuthGuard('jwt').prototype, 'canActivate')
      .mockReturnValue(true);

    const result = await guard.canActivate(mockContext);

    expect(result).toBe(true);
    expect(superCanActivateSpy).toHaveBeenCalled();
  });
});


================================================================================
File: bff-nestjs/src/auth/guards/at.guard.ts
Size: 788 B
================================================================================

// src/auth/guards/at.guard.ts
import { ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { AuthGuard } from '@nestjs/passport';
import { IS_PUBLIC_KEY } from '../../common/decorators/public.decorator';

@Injectable()
export class AtGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext) {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    // English: Log for debugging
    console.log(
      `--- AtGuard --- Route: ${context.getHandler().name} | Public: ${isPublic}`,
    );

    if (isPublic) return true;

    return super.canActivate(context);
  }
}


================================================================================
File: bff-nestjs/src/auth/guards/rt.guard.ts
Size: 199 B
================================================================================

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class RtGuard extends AuthGuard('jwt-refresh') {
  constructor() {
    super();
  }
}


================================================================================
File: bff-nestjs/src/auth/guards/ws-jwt.guard.ts
Size: 1.66 kB
================================================================================

import {
  CanActivate,
  ExecutionContext,
  Injectable,
  Logger,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { WsException } from '@nestjs/websockets';

@Injectable()
export class WsJwtGuard implements CanActivate {
  private readonly logger = new Logger(WsJwtGuard.name);

  constructor(
    private jwtService: JwtService,
    private config: ConfigService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    try {
      const client = context.switchToWs().getClient();

      // English: Extract token from handshake auth or headers (standard WS Auth flow)
      const token =
        client.handshake?.auth?.token ||
        client.handshake?.headers?.authorization?.split(' ')[1];

      if (!token) {
        this.logger.warn(
          'WebSocket connection attempt rejected: No token provided',
        );
        throw new WsException('Unauthorized');
      }

      // English: Verify the access token using the global AT_SECRET
      const payload = await this.jwtService.verifyAsync(token, {
        secret: this.config.get<string>('AT_SECRET'),
      });

      // English: Attach the user payload to the client for use in event handlers (@ConnectedSocket)
      client.user = payload;

      return true;
    } catch (error: unknown) {
      // English: Handle unknown error type to ensure production stability
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`WebSocket JWT Verification failed: ${errorMessage}`);

      throw new WsException('Unauthorized');
    }
  }
}


================================================================================
File: bff-nestjs/src/auth/strategies/at.strategy.ts
Size: 763 B
================================================================================

import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { Role } from '@prisma/client';

// English: Updated payload to include the user's role
type JwtPayload = {
  sub: number;
  email: string;
  role: Role;
};

@Injectable()
export class AtStrategy extends PassportStrategy(Strategy, 'jwt') {
  constructor(config: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: config.getOrThrow<string>('AT_SECRET'),
    });
  }

  validate(payload: JwtPayload) {
    // English: Whatever is returned here is attached to request.user
    return payload;
  }
}


================================================================================
File: bff-nestjs/src/auth/strategies/index.ts
Size: 115 B
================================================================================

// English: Barrel file to simplify strategy imports
export * from './at.strategy';
export * from './rt.strategy';


================================================================================
File: bff-nestjs/src/auth/strategies/rt.strategy.ts
Size: 989 B
================================================================================

import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { Request } from 'express';
import { Injectable, ForbiddenException } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class RtStrategy extends PassportStrategy(Strategy, 'jwt-refresh') {
  constructor(config: ConfigService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      // English: Use getOrThrow to ensure the app fails if the secret is missing
      secretOrKey: config.getOrThrow<string>('RT_SECRET'),
      passReqToCallback: true,
    });
  }

  // English: Improved typing for strict mode
  validate(req: Request, payload: any) {
    const authHeader = req.get('authorization');
    if (!authHeader) throw new ForbiddenException('Refresh token missing');

    const refreshToken = authHeader.replace('Bearer', '').trim();

    return {
      ...payload,
      refreshToken,
    };
  }
}


================================================================================
File: bff-nestjs/src/common/config/env.validation.ts
Size: 695 B
================================================================================

// src/common/config/env.validation.ts
import * as Joi from 'joi';

export const envValidationSchema = Joi.object({
  NODE_ENV: Joi.string()
    .valid('development', 'production', 'test')
    .default('development'),
  PORT: Joi.number().default(3001),
  DATABASE_URL: Joi.string().required(),

  AT_SECRET: Joi.string().required(),
  RT_SECRET: Joi.string().required(),

  REDIS_HOST: Joi.string().default('localhost'),
  REDIS_PORT: Joi.number().default(6379),

  MAIL_HOST: Joi.string().required(),
  MAIL_PORT: Joi.number().required(),
  MAIL_USER: Joi.string().required(),
  MAIL_PASS: Joi.string().required(),
  MAIL_FROM: Joi.string().default('"Team Platform" <no-reply@test.com>'),
});


================================================================================
File: bff-nestjs/src/common/decorators/get-current-user-id.decorator.spec.ts
Size: 1.09 kB
================================================================================

import { ExecutionContext } from '@nestjs/common';
import { ROUTE_ARGS_METADATA } from '@nestjs/common/constants';
import { GetCurrentUserId } from './get-current-user-id.decorator';

function getDecoratorFactory(decorator: any) {
  class Test {
    test(@decorator() value: any) {}
  }
  const args = Reflect.getMetadata(ROUTE_ARGS_METADATA, Test, 'test');
  return args[Object.keys(args)[0]].factory;
}

describe('GetCurrentUserId Decorator', () => {
  const factory = getDecoratorFactory(GetCurrentUserId);

  it('should return user sub from request', () => {
    const mockContext = {
      switchToHttp: () => ({
        getRequest: () => ({
          user: { sub: 123 },
        }),
      }),
    } as unknown as ExecutionContext;

    expect(factory(undefined, mockContext)).toBe(123);
  });

  it('should return null if no user is present', () => {
    const mockContext = {
      switchToHttp: () => ({
        getRequest: () => ({
          user: null,
        }),
      }),
    } as unknown as ExecutionContext;

    expect(factory(undefined, mockContext)).toBeNull();
  });
});


================================================================================
File: bff-nestjs/src/common/decorators/get-current-user-id.decorator.ts
Size: 335 B
================================================================================

import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const GetCurrentUserId = createParamDecorator(
  (data: undefined, context: ExecutionContext): number | null => {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    return user ? (user as any).sub : null;
  },
);


================================================================================
File: bff-nestjs/src/common/decorators/get-current-user-role.decorator.spec.ts
Size: 1 kB
================================================================================

import { ExecutionContext } from '@nestjs/common';
import { ROUTE_ARGS_METADATA } from '@nestjs/common/constants';
import { GetCurrentUserRole } from './get-current-user-role.decorator';

function getDecoratorFactory(decorator: any) {
  class Test {
    test(@decorator() value: any) {}
  }
  const args = Reflect.getMetadata(ROUTE_ARGS_METADATA, Test, 'test');
  return args[Object.keys(args)[0]].factory;
}

describe('GetCurrentUserRole Decorator', () => {
  const factory = getDecoratorFactory(GetCurrentUserRole);

  it('should return user role', () => {
    const context = {
      switchToHttp: () => ({ getRequest: () => ({ user: { role: 'ADMIN' } }) }),
    } as unknown as ExecutionContext;

    expect(factory(undefined, context)).toBe('ADMIN');
  });

  it('should return null if no user', () => {
    const context = {
      switchToHttp: () => ({ getRequest: () => ({ user: null }) }),
    } as unknown as ExecutionContext;

    expect(factory(undefined, context)).toBeNull();
  });
});


================================================================================
File: bff-nestjs/src/common/decorators/get-current-user-role.decorator.ts
Size: 373 B
================================================================================

import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { Role } from '@prisma/client';

export const GetCurrentUserRole = createParamDecorator(
  (data: unknown, context: ExecutionContext): Role | null => {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    return user ? (user as any).role : null;
  },
);


================================================================================
File: bff-nestjs/src/common/decorators/get-current-user.decorator.spec.ts
Size: 1.14 kB
================================================================================

import { ExecutionContext } from '@nestjs/common';
import { ROUTE_ARGS_METADATA } from '@nestjs/common/constants';
import { GetCurrentUser } from './get-current-user.decorator';

function getDecoratorFactory(decorator: any) {
  class Test {
    test(@decorator() value: any) {}
  }
  const args = Reflect.getMetadata(ROUTE_ARGS_METADATA, Test, 'test');
  return args[Object.keys(args)[0]].factory;
}

describe('GetCurrentUser Decorator', () => {
  const factory = getDecoratorFactory(GetCurrentUser);

  it('should return full user if no data provided', () => {
    const mockUser = { id: 1, email: 'test@test.com' };
    const context = {
      switchToHttp: () => ({ getRequest: () => ({ user: mockUser }) }),
    } as unknown as ExecutionContext;

    expect(factory(undefined, context)).toEqual(mockUser);
  });

  it('should return specific property if data provided', () => {
    const mockUser = { id: 1, email: 'test@test.com' };
    const context = {
      switchToHttp: () => ({ getRequest: () => ({ user: mockUser }) }),
    } as unknown as ExecutionContext;

    expect(factory('email', context)).toBe('test@test.com');
  });
});


================================================================================
File: bff-nestjs/src/common/decorators/get-current-user.decorator.ts
Size: 321 B
================================================================================

import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const GetCurrentUser = createParamDecorator(
  (data: string | undefined, context: ExecutionContext) => {
    const request = context.switchToHttp().getRequest();
    if (!data) return request.user;
    return request.user?.[data];
  },
);


================================================================================
File: bff-nestjs/src/common/decorators/index.ts
Size: 217 B
================================================================================

export * from './public.decorator';
export * from './get-current-user-id.decorator';
export * from './get-current-user-role.decorator';
export * from './get-current-user.decorator';
export * from './roles.decorator';


================================================================================
File: bff-nestjs/src/common/decorators/public.decorator.ts
Size: 150 B
================================================================================

import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);


================================================================================
File: bff-nestjs/src/common/decorators/roles.decorator.spec.ts
Size: 511 B
================================================================================

import { Roles, ROLES_KEY } from './roles.decorator';
import { Role } from '@prisma/client';

describe('Roles Decorator', () => {
  it('should set the correct metadata key and values', () => {
    const roles: Role[] = ['ADMIN', 'USER'];
    const decorator = Roles(...roles);

    // English: Create a dummy class to apply the decorator
    const TestTarget = class {};
    decorator(TestTarget);

    const metadata = Reflect.getMetadata(ROLES_KEY, TestTarget);
    expect(metadata).toEqual(roles);
  });
});


================================================================================
File: bff-nestjs/src/common/decorators/roles.decorator.ts
Size: 194 B
================================================================================

import { SetMetadata } from '@nestjs/common';
import { Role } from '@prisma/client';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: Role[]) => SetMetadata(ROLES_KEY, roles);


================================================================================
File: bff-nestjs/src/common/filters/http-exception.filter.spec.ts
Size: 3.18 kB
================================================================================

import { HttpException, HttpStatus } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Test, TestingModule } from '@nestjs/testing';
import { ArgumentsHost } from '@nestjs/common';
import { AllExceptionsFilter } from './http-exception.filter';

describe('AllExceptionsFilter', () => {
  let filter: AllExceptionsFilter;
  let configService: ConfigService;

  const mockResponse = {
    status: jest.fn().mockReturnThis(),
    json: jest.fn().mockReturnThis(),
  };

  const mockRequest = {
    url: '/test-url',
    method: 'POST',
  };

  const mockArgumentsHost = {
    switchToHttp: jest.fn().mockReturnThis(),
    getResponse: jest.fn().mockReturnValue(mockResponse),
    getRequest: jest.fn().mockReturnValue(mockRequest),
  } as unknown as ArgumentsHost;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AllExceptionsFilter,
        {
          provide: ConfigService,
          useValue: {
            get: jest.fn((key: string) => {
              if (key === 'NODE_ENV') return 'development';
              return null;
            }),
          },
        },
      ],
    }).compile();

    filter = module.get<AllExceptionsFilter>(AllExceptionsFilter);
    configService = module.get<ConfigService>(ConfigService);
    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(filter).toBeDefined();
  });

  it('should catch HttpException and return formatted response', () => {
    const exception = new HttpException(
      'Forbidden Access',
      HttpStatus.FORBIDDEN,
    );

    filter.catch(exception, mockArgumentsHost);

    expect(mockResponse.status).toHaveBeenCalledWith(HttpStatus.FORBIDDEN);
    expect(mockResponse.json).toHaveBeenCalledWith(
      expect.objectContaining({
        statusCode: HttpStatus.FORBIDDEN,
        message: 'Forbidden Access',
      }),
    );
  });

  it('should show detailed error message when NOT in production', () => {
    const exception = new Error('Database connection failed');
    jest.spyOn(configService, 'get').mockReturnValue('development');

    filter.catch(exception, mockArgumentsHost);

    expect(mockResponse.json).toHaveBeenCalledWith(
      expect.objectContaining({
        message: 'Database connection failed',
      }),
    );
  });

  it('should hide detailed error message when in production (GDPR compliance)', () => {
    const exception = new Error('Sensitive database error');
    jest.spyOn(configService, 'get').mockReturnValue('production');

    filter.catch(exception, mockArgumentsHost);

    expect(mockResponse.json).toHaveBeenCalledWith(
      expect.objectContaining({
        message: 'Internal server error',
      }),
    );
  });

  it('should log the error with the new structured format', () => {
    const loggerSpy = jest.spyOn((filter as any).logger, 'error');
    const exception = new Error('Critical failure');

    filter.catch(exception, mockArgumentsHost);

    expect(loggerSpy).toHaveBeenCalledWith(
      expect.stringContaining(
        '[POST] /test-url - Status: 500 - Error: Critical failure',
      ),
      exception.stack,
    );
  });
});


================================================================================
File: bff-nestjs/src/common/filters/http-exception.filter.ts
Size: 1.86 kB
================================================================================

import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  HttpStatus,
  Logger,
} from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Request, Response } from 'express';

@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  private readonly logger = new Logger(AllExceptionsFilter.name);

  constructor(private readonly configService: ConfigService) {}

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const nodeEnv = this.configService.get<string>('NODE_ENV');

    const status =
      exception instanceof HttpException
        ? exception.getStatus()
        : HttpStatus.INTERNAL_SERVER_ERROR;

    // English: In production, we must hide specific error details for non-HTTP exceptions (GDPR/Security)
    let message = 'Internal server error';
    if (exception instanceof HttpException) {
      const res = exception.getResponse();
      message = typeof res === 'object' ? (res as any).message : res;
    } else if (nodeEnv !== 'production') {
      // English: Show detailed error only in development/test
      message =
        exception instanceof Error ? exception.message : String(exception);
    }

    const errorResponse = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      method: request.method,
      message: message,
    };

    // English: Structured logging for observability
    this.logger.error(
      `[${request.method}] ${request.url} - Status: ${status} - Error: ${
        exception instanceof Error ? exception.message : 'Unknown'
      }`,
      exception instanceof Error ? exception.stack : undefined,
    );

    response.status(status).json(errorResponse);
  }
}


================================================================================
File: bff-nestjs/src/common/guards/roles.guard.spec.ts
Size: 2.72 kB
================================================================================

import { Reflector } from '@nestjs/core';
import { RolesGuard } from './roles.guard';
import { PrismaService } from '../../prisma/prisma.service';
import { ExecutionContext, ForbiddenException } from '@nestjs/common';
import { Role } from '@prisma/client';

describe('RolesGuard', () => {
  let guard: RolesGuard;
  let reflector: Reflector;
  let prisma: PrismaService;

  const mockReflector = {
    getAllAndOverride: jest.fn(),
  };

  const mockPrisma = {
    teamMember: {
      findUnique: jest.fn(),
    },
  };

  beforeEach(() => {
    reflector = mockReflector as any;
    prisma = mockPrisma as any;
    guard = new RolesGuard(reflector, prisma);
  });

  const createMockContext = (user: any, params: any = {}): ExecutionContext =>
    ({
      switchToHttp: () => ({
        getRequest: () => ({ user, params }),
      }),
      getHandler: jest.fn(),
      getClass: jest.fn(),
    }) as unknown as ExecutionContext;

  it('should allow access if route is public', async () => {
    mockReflector.getAllAndOverride.mockReturnValue(true); // isPublic = true
    const context = createMockContext(null);
    expect(await guard.canActivate(context)).toBe(true);
  });

  it('should allow access if user is global ADMIN', async () => {
    mockReflector.getAllAndOverride
      .mockReturnValueOnce(false)
      .mockReturnValueOnce(null);
    const context = createMockContext({ role: Role.ADMIN });
    expect(await guard.canActivate(context)).toBe(true);
  });

  it('should throw Forbidden if global roles do not match', async () => {
    mockReflector.getAllAndOverride
      .mockReturnValueOnce(false) // isPublic
      .mockReturnValueOnce([Role.ADMIN]); // requiredRoles

    const context = createMockContext({ role: Role.USER });
    await expect(guard.canActivate(context)).rejects.toThrow(
      ForbiddenException,
    );
  });

  it('should validate team membership if teamId is present', async () => {
    mockReflector.getAllAndOverride.mockReturnValue(null);
    const mockUser = { sub: 1, role: Role.USER };
    const context = createMockContext(mockUser, { teamId: '10' });

    mockPrisma.teamMember.findUnique.mockResolvedValue({
      userId: 1,
      teamId: 10,
      role: 'MEMBER',
    });

    expect(await guard.canActivate(context)).toBe(true);
    expect(mockUser['teamRole']).toBe('MEMBER');
  });

  it('should throw Forbidden if user is not in team', async () => {
    mockReflector.getAllAndOverride.mockReturnValue(null);
    const context = createMockContext({ sub: 1 }, { teamId: '10' });

    mockPrisma.teamMember.findUnique.mockResolvedValue(null);

    await expect(guard.canActivate(context)).rejects.toThrow(
      'You are not a member of this team',
    );
  });
});


================================================================================
File: bff-nestjs/src/common/guards/roles.guard.ts
Size: 2.09 kB
================================================================================

import {
  Injectable,
  CanActivate,
  ExecutionContext,
  ForbiddenException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Role, TeamRole } from '@prisma/client'; // Import both
import { ROLES_KEY } from '../decorators/roles.decorator';
import { IS_PUBLIC_KEY } from '../decorators/public.decorator';
import { PrismaService } from '../../prisma/prisma.service';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(
    private reflector: Reflector,
    private prisma: PrismaService, // English: Needed to check team membership
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    // 1. Check if route is public
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isPublic) return true;

    // 2. Get required roles from decorator
    const requiredRoles = this.reflector.getAllAndOverride<Role[]>(ROLES_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);

    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const teamId = parseInt(request.params.teamId);

    // 3. Global Admin Bypass (Enterprise Standard)
    if (user?.role === Role.ADMIN) return true;

    // 4. Validate Global Roles (if @Roles is present)
    if (requiredRoles && !requiredRoles.some((role) => user.role === role)) {
      throw new ForbiddenException('Missing required global role');
    }

    // 5. Team Context Validation (Logic for Team Roles)
    // English: If the URL contains a teamId, we must verify membership
    if (teamId) {
      const membership = await this.prisma.teamMember.findUnique({
        where: {
          userId_teamId: { userId: user.sub, teamId: teamId },
        },
      });

      if (!membership) {
        throw new ForbiddenException('You are not a member of this team');
      }

      // English: Attach membership to request for easy access in controllers
      request.user.teamRole = membership.role;
    }

    return true;
  }
}


================================================================================
File: bff-nestjs/src/common/guards/team-member.guard.spec.ts
Size: 2.04 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { TeamMemberGuard } from './team-member.guard';
import { PrismaService } from '../../prisma/prisma.service';
import { ForbiddenException, ExecutionContext } from '@nestjs/common';

describe('TeamMemberGuard', () => {
  let guard: TeamMemberGuard;
  let prisma: PrismaService;

  const mockPrisma = {
    extended: {
      teamMember: { findFirst: jest.fn() },
    },
  };

  const createMockContext = (
    params: any,
    body: any,
    userId: number,
  ): ExecutionContext =>
    ({
      switchToHttp: () => ({
        getRequest: () => ({
          params,
          body,
          user: { sub: userId },
        }),
      }),
    }) as any;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TeamMemberGuard,
        { provide: PrismaService, useValue: mockPrisma },
      ],
    }).compile();

    guard = module.get<TeamMemberGuard>(TeamMemberGuard);
    prisma = module.get<PrismaService>(PrismaService);
  });

  it('should return true if no teamId is provided (skips check)', async () => {
    const context = createMockContext({}, {}, 1);
    const result = await guard.canActivate(context);
    expect(result).toBe(true);
  });

  it('should allow access if membership exists', async () => {
    (mockPrisma.extended.teamMember.findFirst as jest.Mock).mockResolvedValue({
      id: 1,
    });
    const context = createMockContext({ teamId: '5' }, {}, 1);

    const result = await guard.canActivate(context);
    expect(result).toBe(true);
    expect(mockPrisma.extended.teamMember.findFirst).toHaveBeenCalled();
  });

  it('should throw ForbiddenException if membership does not exist', async () => {
    (mockPrisma.extended.teamMember.findFirst as jest.Mock).mockResolvedValue(
      null,
    );
    const context = createMockContext({}, { teamId: 5 }, 1); // Prueba desde el body

    await expect(guard.canActivate(context)).rejects.toThrow(
      ForbiddenException,
    );
  });
});


================================================================================
File: bff-nestjs/src/common/guards/team-member.guard.ts
Size: 935 B
================================================================================

// src/common/guards/team-member.guard.ts
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  ForbiddenException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';

@Injectable()
export class TeamMemberGuard implements CanActivate {
  constructor(private prisma: PrismaService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const userId = request.user.sub;
    const teamId = parseInt(request.params.teamId || request.body.teamId);

    if (!teamId) return true; // English: Skip if no team context is provided

    const membership = await this.prisma.extended.teamMember.findFirst({
      where: {
        userId,
        teamId,
      },
    });

    if (!membership) {
      throw new ForbiddenException(
        'Access Denied: You do not belong to this team',
      );
    }

    return true;
  }
}


================================================================================
File: bff-nestjs/src/common/guards/team-owner.guard.spec.ts
Size: 2.21 kB
================================================================================

// bff-nestjs/src/common/guards/team-owner.guard.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { TeamOwnerGuard } from './team-owner.guard';
import { PrismaService } from '../../prisma/prisma.service';
import {
  ExecutionContext,
  ForbiddenException,
  NotFoundException,
} from '@nestjs/common';
import { TeamRole } from '@prisma/client';

describe('TeamOwnerGuard', () => {
  let guard: TeamOwnerGuard;
  let prisma: PrismaService;

  const mockPrismaService = {
    extended: {
      teamMember: {
        findUnique: jest.fn(),
      },
    },
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TeamOwnerGuard,
        { provide: PrismaService, useValue: mockPrismaService },
      ],
    }).compile();

    guard = module.get<TeamOwnerGuard>(TeamOwnerGuard);
    prisma = module.get<PrismaService>(PrismaService);
  });

  const createMockContext = (
    userId: number,
    teamId: string,
  ): ExecutionContext =>
    ({
      switchToHttp: () => ({
        getRequest: () => ({
          user: { sub: userId },
          params: { id: teamId },
        }),
      }),
    }) as any;

  it('should be defined', () => {
    expect(guard).toBeDefined();
  });

  it('should allow access if user is OWNER', async () => {
    mockPrismaService.extended.teamMember.findUnique.mockResolvedValue({
      role: TeamRole.OWNER,
    });

    const context = createMockContext(1, '10');
    const result = await guard.canActivate(context);

    expect(result).toBe(true);
  });

  it('should throw ForbiddenException if user is not OWNER', async () => {
    mockPrismaService.extended.teamMember.findUnique.mockResolvedValue({
      role: TeamRole.MEMBER,
    });

    const context = createMockContext(1, '10');
    await expect(guard.canActivate(context)).rejects.toThrow(
      ForbiddenException,
    );
  });

  it('should throw NotFoundException if membership does not exist', async () => {
    mockPrismaService.extended.teamMember.findUnique.mockResolvedValue(null);

    const context = createMockContext(1, '10');
    await expect(guard.canActivate(context)).rejects.toThrow(NotFoundException);
  });
});


================================================================================
File: bff-nestjs/src/common/guards/team-owner.guard.ts
Size: 1.42 kB
================================================================================

// bff-nestjs/src/common/guards/team-owner.guard.ts
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  ForbiddenException,
  NotFoundException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { TeamRole, Role } from '@prisma/client';

@Injectable()
export class TeamOwnerGuard implements CanActivate {
  constructor(private prisma: PrismaService) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const user = request.user;

    // English: Global Admins can bypass owner checks (Enterprise Standard)
    if (user?.role === Role.ADMIN) return true;

    const userId = user?.sub;
    const teamIdRaw = request.params.id || request.params.teamId;
    const teamId = parseInt(teamIdRaw, 10);

    if (!userId || isNaN(teamId)) {
      throw new ForbiddenException('User session or Team ID not found');
    }

    // English: Verify ownership in the specific team
    const membership = await this.prisma.extended.teamMember.findUnique({
      where: {
        userId_teamId: { userId, teamId },
      },
    });

    if (!membership) {
      throw new NotFoundException('Team membership not found');
    }

    if (membership.role !== TeamRole.OWNER) {
      throw new ForbiddenException(
        'Only the team OWNER can perform this action',
      );
    }

    return true;
  }
}


================================================================================
File: bff-nestjs/src/common/prisma/soft-delete.extension.ts
Size: 674 B
================================================================================

// src/common/prisma/soft-delete.extension.ts
import { Prisma } from '@prisma/client';

export const softDeleteExtension = Prisma.defineExtension({
  name: 'softDelete',
  query: {
    $allModels: {
      async findMany({ model, operation, args, query }) {
        args.where = { ...args.where, deletedAt: null };
        return query(args);
      },
      async findFirst({ model, operation, args, query }) {
        args.where = { ...args.where, deletedAt: null };
        return query(args);
      },
      async findUnique({ model, operation, args, query }) {
        args.where = { ...args.where, deletedAt: null };
        return query(args);
      },
    },
  },
});


================================================================================
File: bff-nestjs/src/config/env.validation.ts
Size: 1.77 kB
================================================================================

import * as Joi from 'joi';

export const envValidationSchema = Joi.object({
  // --- ENVIRONMENT ---
  NODE_ENV: Joi.string()
    .valid('development', 'production', 'test', 'staging')
    .default('development'),
  PORT: Joi.number().port().default(3001),
  FRONTEND_URL: Joi.string().uri().required(),

  // --- DATABASE (PostgreSQL 14+) ---
  DATABASE_URL: Joi.string().required(),
  DATABASE_POOL_SIZE: Joi.number().min(1).max(100).default(10),

  // --- AUTHENTICATION & SECURITY ---
  AT_SECRET: Joi.string().min(32).required(),
  RT_SECRET: Joi.string().min(32).required(),
  COOKIE_SECRET: Joi.string().min(32).required(), // Crucial for signed cookies
  AT_EXPIRES_IN: Joi.string().default('15m'),
  RT_EXPIRES_IN: Joi.string().default('7d'),

  // --- REDIS (Queues/BullMQ) ---
  REDIS_HOST: Joi.string().required(),
  REDIS_PORT: Joi.number().port().default(6379),
  REDIS_PASSWORD: Joi.string().allow('').optional(),

  // --- MAIL (SaaS Standard) ---
  MAIL_HOST: Joi.string().required(),
  MAIL_PORT: Joi.number().port().required(),
  MAIL_USER: Joi.string().required(),
  MAIL_PASS: Joi.string().required(),
  MAIL_FROM: Joi.string().default('"Team Platform" <no-reply@yourdomain.com>'),

  // --- STORAGE (Supabase S3 Compatible) ---
  STORAGE_ENDPOINT: Joi.string().uri().required(),
  STORAGE_REGION: Joi.string().required(),
  STORAGE_ACCESS_KEY: Joi.string().required(),
  STORAGE_SECRET_KEY: Joi.string().required(),
  STORAGE_BUCKET: Joi.string().required(),
  STORAGE_FORCE_PATH_STYLE: Joi.boolean().default(true), // Specific for Supabase/Minio

  // --- MONITORING ---
  LOG_LEVEL: Joi.string().valid('debug', 'info', 'warn', 'error').default('info'),
  THROTTLE_TTL: Joi.number().default(60000),
  THROTTLE_LIMIT: Joi.number().default(20),
});

================================================================================
File: bff-nestjs/src/main.ts
Size: 2.99 kB
================================================================================

import { ClassSerializerInterceptor, ValidationPipe } from '@nestjs/common';
import { NestFactory, Reflector } from '@nestjs/core';
import { ConfigService } from '@nestjs/config';
import { Logger } from 'nestjs-pino';
import cookieParser from 'cookie-parser'; // Fixed: Default import for TS2349 compatibility
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { NestExpressApplication } from '@nestjs/platform-express';

import { AppModule } from './app.module';
import { AllExceptionsFilter } from './common/filters/http-exception.filter';

async function bootstrap() {
  // English: Create the app with NestExpressApplication type to access Express methods
  const app = await NestFactory.create<NestExpressApplication>(AppModule, {
    bufferLogs: true,
  });

  // English: Security enhancement - Hide the underlying technology (Express)
  app.disable('x-powered-by');

  // English: Set Pino as the primary logger for structured JSON logging
  app.useLogger(app.get(Logger));

  const configService = app.get(ConfigService);
  const port = configService.get<number>('PORT') || 3001;
  const frontendUrl = configService.get<string>('FRONTEND_URL');
  const cookieSecret = configService.get<string>('COOKIE_SECRET');
  const nodeEnv = configService.get<string>('NODE_ENV');

  app.setGlobalPrefix('api/v1');

  // English: Cookie signing is mandatory for SaaS security to prevent client-side tampering
  app.use(cookieParser(cookieSecret));

  // English: Strict CORS configuration pulling from validated environment variables
  app.enableCors({
    origin: frontendUrl,
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'set-cookie'],
  });

  // English: Global validation pipes for DTO integrity
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    }),
  );

  // English: Global exception filter for GDPR and security compliance
  app.useGlobalFilters(new AllExceptionsFilter(configService));

  const reflector = app.get(Reflector);
  app.useGlobalInterceptors(new ClassSerializerInterceptor(reflector));

  // English: Swagger API Documentation - restricted to non-production environments
  if (nodeEnv !== 'production') {
    const config = new DocumentBuilder()
      .setTitle('Team Productivity Platform')
      .setDescription('BFF Enterprise API - German Market Standard')
      .setVersion('1.0')
      .addBearerAuth({ type: 'http', scheme: 'bearer' }, 'access-token')
      .build();

    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup('api/docs', app, document);
  }

  await app.listen(port);

  // English: Initial bootstrap info
  console.log(`üöÄ Application is running on: http://localhost:${port}/api/v1`);
  if (nodeEnv !== 'production') {
    console.log(`üìö Documentation: http://localhost:${port}/api/docs`);
  }
}
bootstrap();


================================================================================
File: bff-nestjs/src/modules/dashboard/dashboard.controller.spec.ts
Size: 1.29 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { DashboardController } from './dashboard.controller';
import { DashboardService } from './dashboard.service';
import { RolesGuard } from '../../common/guards/roles.guard';

describe('DashboardController', () => {
  let controller: DashboardController;
  let service: DashboardService;

  const mockDashboardService = {
    getTeamStats: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [DashboardController],
      providers: [
        { provide: DashboardService, useValue: mockDashboardService },
      ],
    })
      .overrideGuard(RolesGuard)
      .useValue({ canActivate: () => true })
      .compile();

    controller = module.get<DashboardController>(DashboardController);
    service = module.get<DashboardService>(DashboardService);
  });

  it('should return stats for a team via service', async () => {
    const mockStats = {
      teamName: 'Team Alpha',
      totalProjects: 1,
      projects: [],
    };
    mockDashboardService.getTeamStats.mockResolvedValue(mockStats);

    const result = await controller.getStats(1);

    expect(service.getTeamStats).toHaveBeenCalledWith(1);
    expect(result).toEqual(mockStats);
  });
});


================================================================================
File: bff-nestjs/src/modules/dashboard/dashboard.controller.ts
Size: 688 B
================================================================================

import {
  Controller,
  Get,
  Param,
  ParseIntPipe,
  UseGuards,
} from '@nestjs/common';
import { DashboardService } from './dashboard.service';
import { RolesGuard } from '../../common/guards/roles.guard';
import { ApiTags, ApiBearerAuth } from '@nestjs/swagger';

@ApiTags('Dashboard')
@ApiBearerAuth('access-token')
@UseGuards(RolesGuard) // English: Crucial - verified team membership automatically
@Controller('dashboard')
export class DashboardController {
  constructor(private readonly dashboardService: DashboardService) {}

  @Get('team/:teamId')
  async getStats(@Param('teamId', ParseIntPipe) teamId: number) {
    return this.dashboardService.getTeamStats(teamId);
  }
}


================================================================================
File: bff-nestjs/src/modules/dashboard/dashboard.module.ts
Size: 362 B
================================================================================

import { Module } from '@nestjs/common';
import { DashboardService } from './dashboard.service';
import { DashboardController } from './dashboard.controller';
import { PrismaModule } from '../../prisma/prisma.module';

@Module({
  imports: [PrismaModule],
  controllers: [DashboardController],
  providers: [DashboardService],
})
export class DashboardModule {}


================================================================================
File: bff-nestjs/src/modules/dashboard/dashboard.service.spec.ts
Size: 2.37 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { DashboardService } from './dashboard.service';
import { PrismaService } from '../../prisma/prisma.service';
import { NotFoundException } from '@nestjs/common';
import { TaskStatus } from '@prisma/client';

describe('DashboardService', () => {
  let service: DashboardService;
  let prisma: PrismaService;

  const mockPrisma = {
    extended: {
      team: {
        findUnique: jest.fn(),
      },
    },
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        DashboardService,
        { provide: PrismaService, useValue: mockPrisma },
      ],
    }).compile();

    service = module.get<DashboardService>(DashboardService);
    prisma = module.get<PrismaService>(PrismaService);
  });

  it('should calculate team stats correctly (Success)', async () => {
    const pastDate = new Date();
    pastDate.setDate(pastDate.getDate() - 5);

    const mockTeam = {
      name: 'Development Team',
      projects: [
        {
          id: 101,
          name: 'Project X',
          _count: { tasks: 2 },
          tasks: [
            { status: TaskStatus.DONE, dueDate: null },
            { status: TaskStatus.IN_PROGRESS, dueDate: pastDate }, // Overdue
          ],
        },
      ],
    };

    (mockPrisma.extended.team.findUnique as jest.Mock).mockResolvedValue(
      mockTeam,
    );

    const result = await service.getTeamStats(1);

    expect(result.teamName).toBe('Development Team');
    expect(result.projects[0].progress).toBe(50); // 1 done of 2
    expect(result.projects[0].overdueTasks).toBe(1);
    expect(result.projects[0].completedTasks).toBe(1);
  });

  it('should return 0 progress if project has no tasks', async () => {
    const mockTeam = {
      name: 'Empty Team',
      projects: [{ id: 1, name: 'Empty P', _count: { tasks: 0 }, tasks: [] }],
    };
    (mockPrisma.extended.team.findUnique as jest.Mock).mockResolvedValue(
      mockTeam,
    );

    const result = await service.getTeamStats(1);
    expect(result.projects[0].progress).toBe(0);
  });

  it('should throw NotFoundException if team does not exist', async () => {
    (mockPrisma.extended.team.findUnique as jest.Mock).mockResolvedValue(null);
    await expect(service.getTeamStats(999)).rejects.toThrow(NotFoundException);
  });
});


================================================================================
File: bff-nestjs/src/modules/dashboard/dashboard.service.ts
Size: 1.57 kB
================================================================================

import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { TaskStatus } from '@prisma/client';

@Injectable()
export class DashboardService {
  constructor(private prisma: PrismaService) {}

  async getTeamStats(teamId: number) {
    const team = await this.prisma.extended.team.findUnique({
      where: { id: teamId },
      include: {
        projects: {
          include: {
            _count: {
              select: { tasks: true },
            },
            tasks: {
              select: { status: true, dueDate: true },
            },
          },
        },
      },
    });

    if (!team) throw new NotFoundException(`Team with ID ${teamId} not found`);

    const now = new Date();
    const projectStats = team.projects.map((project) => {
      const totalTasks = project._count.tasks;
      const completedTasks = project.tasks.filter(
        (t) => t.status === TaskStatus.DONE,
      ).length;

      const progress =
        totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
      const overdueTasks = project.tasks.filter(
        (t) =>
          t.status !== TaskStatus.DONE &&
          t.dueDate &&
          new Date(t.dueDate) < now,
      ).length;

      return {
        id: project.id,
        name: project.name,
        progress,
        totalTasks,
        completedTasks,
        overdueTasks,
      };
    });

    return {
      teamName: team.name,
      totalProjects: team.projects.length,
      projects: projectStats,
    };
  }
}


================================================================================
File: bff-nestjs/src/modules/dashboard/dto/project-stats.dto.ts
Size: 373 B
================================================================================

import { ApiProperty } from '@nestjs/swagger';

export class ProjectStatsDto {
  @ApiProperty()
  projectId!: number;

  @ApiProperty()
  projectName!: string;

  @ApiProperty()
  totalTasks!: number;

  @ApiProperty()
  completedTasks!: number;

  @ApiProperty()
  pendingTasks!: number;

  @ApiProperty()
  overdueTasks!: number;

  @ApiProperty()
  progress!: number;
}


================================================================================
File: bff-nestjs/src/modules/health/health.controller.ts
Size: 628 B
================================================================================

import { Controller, Get } from '@nestjs/common';
import {
  HealthCheckService,
  PrismaHealthIndicator,
  HealthCheck,
} from '@nestjs/terminus';
import { PrismaService } from '../../prisma/prisma.service';
import { Public } from '../../common/decorators';

@Controller('health')
export class HealthController {
  constructor(
    private health: HealthCheckService,
    private prismaIndicator: PrismaHealthIndicator,
    private prisma: PrismaService,
  ) {}

  @Public()
  @Get()
  @HealthCheck()
  check() {
    return this.health.check([
      () => this.prismaIndicator.pingCheck('database', this.prisma),
    ]);
  }
}


================================================================================
File: bff-nestjs/src/modules/health/health.module.ts
Size: 328 B
================================================================================

import { Module } from '@nestjs/common';
import { TerminusModule } from '@nestjs/terminus';
import { HealthController } from './health.controller';
import { PrismaModule } from '../../prisma/prisma.module';

@Module({
  imports: [TerminusModule, PrismaModule],
  controllers: [HealthController],
})
export class HealthModule {}


================================================================================
File: bff-nestjs/src/modules/invitations/dto/invitation.dto.ts
Size: 470 B
================================================================================

import { IsEmail, IsEnum, IsNotEmpty, IsString } from 'class-validator';
import { TeamRole } from '@prisma/client';

export class SendInvitationDto {
  @IsEmail()
  @IsNotEmpty()
  email!: string; // English: Added '!' to fix TS2564 Property has no initializer

  @IsEnum(TeamRole)
  role: TeamRole = TeamRole.MEMBER;
}

export class AcceptInvitationDto {
  @IsString()
  @IsNotEmpty()
  token!: string; // English: Added '!' to fix TS2564 Property has no initializer
}


================================================================================
File: bff-nestjs/src/modules/invitations/invitations.controller.spec.ts
Size: 1.51 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { InvitationsController } from './invitations.controller';
import { InvitationsService } from './invitations.service';
import { AtGuard } from '../../auth/guards/at.guard';
import { TeamRole } from '@prisma/client';

describe('InvitationsController', () => {
  let controller: InvitationsController;
  let service: InvitationsService;

  const mockInvitationsService = {
    createInvitation: jest.fn(),
    acceptInvitation: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [InvitationsController],
      providers: [
        { provide: InvitationsService, useValue: mockInvitationsService },
      ],
    })
      .overrideGuard(AtGuard)
      .useValue({ canActivate: () => true })
      .compile();

    controller = module.get<InvitationsController>(InvitationsController);
    service = module.get<InvitationsService>(InvitationsService);
  });

  it('should call createInvitation service', async () => {
    const dto = { email: 'test@test.com', role: TeamRole.MEMBER };
    await controller.invite(1, 10, dto);
    expect(service.createInvitation).toHaveBeenCalledWith(
      1,
      10,
      dto.email,
      dto.role,
    );
  });

  it('should call acceptInvitation service', async () => {
    const dto = { token: 'valid-token' };
    await controller.accept(dto, 10);
    expect(service.acceptInvitation).toHaveBeenCalledWith(dto.token, 10);
  });
});


================================================================================
File: bff-nestjs/src/modules/invitations/invitations.controller.ts
Size: 1.35 kB
================================================================================

import {
  Controller,
  Post,
  Body,
  UseGuards,
  Param,
  ParseIntPipe,
} from '@nestjs/common';
import { InvitationsService } from './invitations.service';
import { AtGuard } from '../../auth/guards/at.guard';
import { GetCurrentUserId } from '../../common/decorators';
import { ApiTags, ApiOperation, ApiBearerAuth } from '@nestjs/swagger';
import { SendInvitationDto, AcceptInvitationDto } from './dto/invitation.dto';

@ApiTags('invitations')
@ApiBearerAuth()
@UseGuards(AtGuard)
@Controller('invitations')
export class InvitationsController {
  constructor(private readonly invitationsService: InvitationsService) {}

  @Post('team/:teamId/send')
  @ApiOperation({ summary: 'Send an email invitation to join a team' })
  async invite(
    @Param('teamId', ParseIntPipe) teamId: number,
    @GetCurrentUserId() userId: number,
    @Body() dto: SendInvitationDto,
  ) {
    // English: Changed to createInvitation to match your Service method name
    return this.invitationsService.createInvitation(
      teamId,
      userId,
      dto.email,
      dto.role,
    );
  }

  @Post('accept')
  @ApiOperation({ summary: 'Accept a team invitation using a token' })
  async accept(
    @Body() dto: AcceptInvitationDto,
    @GetCurrentUserId() userId: number,
  ) {
    return this.invitationsService.acceptInvitation(dto.token, userId);
  }
}


================================================================================
File: bff-nestjs/src/modules/invitations/invitations.module.ts
Size: 860 B
================================================================================

import { Module } from '@nestjs/common';
import { InvitationsService } from './invitations.service';
import { InvitationsController } from './invitations.controller';
import { PrismaModule } from '../../prisma/prisma.module';
import { MailModule } from '../mail/mail.module';
import { JwtModule } from '@nestjs/jwt';
import { NotificationsModule } from '../notifications/notifications.module'; // English: Added missing module

@Module({
  imports: [
    PrismaModule,
    MailModule,
    NotificationsModule, // English: Required for NotificationsGateway in InvitationsService
    JwtModule.register({
      secret: process.env.JWT_SECRET || 'fallback_secret',
      signOptions: { expiresIn: '7d' },
    }),
  ],
  controllers: [InvitationsController],
  providers: [InvitationsService],
  exports: [InvitationsService],
})
export class InvitationsModule {}


================================================================================
File: bff-nestjs/src/modules/invitations/invitations.processor.spec.ts
Size: 1.48 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { InvitationsProcessor } from './invitations.processor';
import { MailService } from '../mail/mail.service';
import { Logger } from '@nestjs/common';

describe('InvitationsProcessor', () => {
  let processor: InvitationsProcessor;
  let mailService: MailService;

  const mockMailService = {
    sendInvitationEmail: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        InvitationsProcessor,
        { provide: MailService, useValue: mockMailService },
      ],
    }).compile();

    processor = module.get<InvitationsProcessor>(InvitationsProcessor);
    mailService = module.get<MailService>(MailService);
  });

  it('should process send-invitation job', async () => {
    const job = {
      id: '1',
      name: 'send-invitation',
      data: { email: 'test@test.com', token: '123', teamName: 'Team A' },
    } as any;

    await processor.process(job);

    expect(mailService.sendInvitationEmail).toHaveBeenCalledWith(
      'test@test.com',
      'Team A',
      '123',
    );
  });

  it('should log warning for unknown job name', async () => {
    const loggerSpy = jest.spyOn(Logger.prototype, 'warn');
    const job = { id: '2', name: 'unknown-task', data: {} } as any;

    await processor.process(job);

    expect(loggerSpy).toHaveBeenCalledWith(
      expect.stringContaining('Unknown job name'),
    );
  });
});


================================================================================
File: bff-nestjs/src/modules/invitations/invitations.processor.ts
Size: 856 B
================================================================================

import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { Logger } from '@nestjs/common';
import { MailService } from '../mail/mail.service';

@Processor('mail-queue')
export class InvitationsProcessor extends WorkerHost {
  private readonly logger = new Logger(InvitationsProcessor.name);

  constructor(private readonly mailService: MailService) {
    super();
  }

  async process(job: Job<any, any, string>): Promise<any> {
    this.logger.log(`Processing job ${job.id} of type ${job.name}...`);

    switch (job.name) {
      case 'send-invitation':
        const { email, token, teamName } = job.data;
        return await this.mailService.sendInvitationEmail(
          email,
          teamName,
          token,
        );

      default:
        this.logger.warn(`Unknown job name: ${job.name}`);
    }
  }
}


================================================================================
File: bff-nestjs/src/modules/invitations/invitations.service.spec.ts
Size: 8 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { InvitationsService } from './invitations.service';
import { PrismaService } from '../../prisma/prisma.service';
import { JwtService } from '@nestjs/jwt';
import { NotificationsGateway } from '../notifications/notifications.gateway';
import { MailService } from '../mail/mail.service';
import {
  BadRequestException,
  NotFoundException,
  ForbiddenException,
} from '@nestjs/common';
import { TeamRole, InvitationStatus } from '@prisma/client';

describe('InvitationsService', () => {
  let service: InvitationsService;
  let prisma: PrismaService;
  let jwt: JwtService;

  const mockTeamId = 1;
  const mockInviterId = 10;
  const mockUserId = 5;
  const mockEmail = 'guest@test.com';
  const mockToken = 'valid-jwt-token';

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        InvitationsService,
        {
          provide: PrismaService,
          useValue: {
            team: { findUnique: jest.fn() },
            teamMember: { findFirst: jest.fn(), create: jest.fn() },
            invitation: {
              create: jest.fn(),
              findUnique: jest.fn(),
              update: jest.fn(),
            },
            user: { findUnique: jest.fn() },
            $transaction: jest.fn((promises) => Promise.all(promises)),
          },
        },
        {
          provide: JwtService,
          useValue: {
            sign: jest.fn().mockReturnValue(mockToken),
            verifyAsync: jest.fn(),
          },
        },
        {
          provide: NotificationsGateway,
          useValue: { notifyInvitationAccepted: jest.fn() },
        },
        {
          provide: MailService,
          useValue: { sendInvitationEmail: jest.fn().mockResolvedValue(true) },
        },
      ],
    }).compile();

    service = module.get<InvitationsService>(InvitationsService);
    prisma = module.get<PrismaService>(PrismaService);
    jwt = module.get<JwtService>(JwtService);
  });

  describe('createInvitation', () => {
    it('should create an invitation successfully', async () => {
      const mockTeam = {
        id: mockTeamId,
        name: 'Team Jest',
        members: [
          {
            userId: mockInviterId,
            role: TeamRole.OWNER,
            teamId: mockTeamId,
          },
        ],
      };

      (prisma.team.findUnique as jest.Mock).mockResolvedValue(mockTeam);
      (prisma.teamMember.findFirst as jest.Mock).mockResolvedValue(null);
      (prisma.user.findUnique as jest.Mock).mockResolvedValue({
        id: mockInviterId,
        email: 'owner@test.com',
      });
      (prisma.invitation.create as jest.Mock).mockResolvedValue({ id: 500 });

      const result = await service.createInvitation(
        mockTeamId,
        mockInviterId,
        mockEmail,
      );

      expect(result.message).toBe('Invitation sent successfully');
      expect(result.invitationId).toBe(500);
      expect(prisma.invitation.create).toHaveBeenCalled();
    });

    it('should throw NotFoundException if team does not exist', async () => {
      (prisma.team.findUnique as jest.Mock).mockResolvedValue(null);

      await expect(
        service.createInvitation(999, mockInviterId, mockEmail),
      ).rejects.toThrow(NotFoundException);
    });

    it('should throw ForbiddenException if inviter is not team owner', async () => {
      const mockTeam = {
        id: mockTeamId,
        name: 'Team Jest',
        members: [
          {
            userId: mockInviterId,
            role: TeamRole.MEMBER,
            teamId: mockTeamId,
          },
        ],
      };

      (prisma.team.findUnique as jest.Mock).mockResolvedValue(mockTeam);

      await expect(
        service.createInvitation(mockTeamId, mockInviterId, mockEmail),
      ).rejects.toThrow(ForbiddenException);
    });

    it('should throw BadRequestException if user is already a member', async () => {
      const mockTeam = {
        id: mockTeamId,
        name: 'Team Jest',
        members: [
          {
            userId: mockInviterId,
            role: TeamRole.OWNER,
            teamId: mockTeamId,
          },
        ],
      };

      (prisma.team.findUnique as jest.Mock).mockResolvedValue(mockTeam);
      (prisma.teamMember.findFirst as jest.Mock).mockResolvedValue({ id: 1 });

      await expect(
        service.createInvitation(mockTeamId, mockInviterId, mockEmail),
      ).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException if user tries to invite themselves', async () => {
      const mockTeam = {
        id: mockTeamId,
        name: 'Team Jest',
        members: [
          {
            userId: mockInviterId,
            role: TeamRole.OWNER,
            teamId: mockTeamId,
          },
        ],
      };

      (prisma.team.findUnique as jest.Mock).mockResolvedValue(mockTeam);
      (prisma.teamMember.findFirst as jest.Mock).mockResolvedValue(null);
      (prisma.user.findUnique as jest.Mock).mockResolvedValue({
        id: mockInviterId,
        email: mockEmail,
      });

      await expect(
        service.createInvitation(mockTeamId, mockInviterId, mockEmail),
      ).rejects.toThrow(BadRequestException);
    });
  });

  describe('acceptInvitation', () => {
    const mockPayload = {
      teamId: mockTeamId,
      email: mockEmail,
      role: TeamRole.MEMBER,
    };
    const mockInvitationDb = {
      id: 100,
      token: mockToken,
      status: InvitationStatus.PENDING,
      expiresAt: new Date(Date.now() + 10000),
      teamId: mockTeamId,
    };

    it('should accept an invitation successfully', async () => {
      (jwt.verifyAsync as jest.Mock).mockResolvedValue(mockPayload);
      (prisma.invitation.findUnique as jest.Mock).mockResolvedValue(
        mockInvitationDb,
      );
      (prisma.user.findUnique as jest.Mock).mockResolvedValue({
        id: mockUserId,
        email: mockEmail,
        name: 'Nikolas',
      });

      const result = await service.acceptInvitation(mockToken, mockUserId);

      expect(result.message).toBe('Joined the team successfully');
      expect(prisma.$transaction).toHaveBeenCalled();
    });

    it('should throw ForbiddenException if email in token does not match user email', async () => {
      (jwt.verifyAsync as jest.Mock).mockResolvedValue(mockPayload);
      (prisma.invitation.findUnique as jest.Mock).mockResolvedValue(
        mockInvitationDb,
      );
      (prisma.user.findUnique as jest.Mock).mockResolvedValue({
        id: mockUserId,
        email: 'other@test.com',
      });

      await expect(
        service.acceptInvitation(mockToken, mockUserId),
      ).rejects.toThrow(ForbiddenException);
    });

    it('should throw BadRequestException if invitation is already accepted', async () => {
      (jwt.verifyAsync as jest.Mock).mockResolvedValue(mockPayload);
      (prisma.invitation.findUnique as jest.Mock).mockResolvedValue({
        ...mockInvitationDb,
        status: InvitationStatus.ACCEPTED,
      });

      await expect(
        service.acceptInvitation(mockToken, mockUserId),
      ).rejects.toThrow(BadRequestException);
    });

    it('should throw BadRequestException if token is expired (JWT error)', async () => {
      const error = new Error();
      error.name = 'TokenExpiredError';
      (jwt.verifyAsync as jest.Mock).mockRejectedValue(error);

      await expect(
        service.acceptInvitation('expired', mockUserId),
      ).rejects.toThrow(BadRequestException);
    });

    it('should throw NotFoundException if user is not found', async () => {
      (jwt.verifyAsync as jest.Mock).mockResolvedValue(mockPayload);
      (prisma.invitation.findUnique as jest.Mock).mockResolvedValue(
        mockInvitationDb,
      );
      (prisma.user.findUnique as jest.Mock).mockResolvedValue(null);

      await expect(
        service.acceptInvitation(mockToken, mockUserId),
      ).rejects.toThrow(NotFoundException);
    });
  });
});


================================================================================
File: bff-nestjs/src/modules/invitations/invitations.service.ts
Size: 4.64 kB
================================================================================

import {
  Injectable,
  BadRequestException,
  NotFoundException,
  ForbiddenException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../../prisma/prisma.service';
import { NotificationsGateway } from '../notifications/notifications.gateway';
import { MailService } from '../mail/mail.service';
import { TeamRole, InvitationStatus } from '@prisma/client';

@Injectable()
export class InvitationsService {
  constructor(
    private prisma: PrismaService,
    private jwtService: JwtService,
    private notifications: NotificationsGateway,
    private mailService: MailService,
  ) {}

  async createInvitation(
    teamId: number,
    inviterId: number,
    targetEmail: string,
    role: TeamRole = TeamRole.MEMBER,
  ) {
    // 1. Check team existence and get members
    const team = await this.prisma.team.findUnique({
      where: { id: teamId },
      include: { members: true },
    });
    if (!team) throw new NotFoundException('Team not found');

    // 2. Check that inviter is OWNER of the team
    const inviterMember = team.members.find((m) => m.userId === inviterId);
    if (!inviterMember) {
      throw new ForbiddenException('You are not a member of this team');
    }
    if (inviterMember.role !== TeamRole.OWNER) {
      throw new ForbiddenException('Only team owners can send invitations');
    }

    const lowerEmail = targetEmail.toLowerCase();

    // 3. Check if user is already a member
    const existingMember = await this.prisma.teamMember.findFirst({
      where: { teamId, user: { email: lowerEmail } },
    });
    if (existingMember)
      throw new BadRequestException('User is already a member of this team');

    // 4. Check that user is not inviting themselves
    const inviterUser = await this.prisma.user.findUnique({
      where: { id: inviterId },
    });
    if (inviterUser?.email.toLowerCase() === lowerEmail) {
      throw new BadRequestException('You cannot invite yourself');
    }

    // 5. Generate JWT token for invitation
    const invitationToken = this.jwtService.sign(
      { teamId, email: lowerEmail, role, inviterId },
      { expiresIn: '7d' },
    );

    // 6. Save invitation to database
    const invitation = await this.prisma.invitation.create({
      data: {
        email: lowerEmail,
        token: invitationToken,
        teamId,
        inviterId,
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        status: InvitationStatus.PENDING,
      },
    });

    // 7. Send invitation email
    await this.mailService.sendInvitationEmail(
      lowerEmail,
      team.name,
      invitationToken,
    );

    return {
      message: 'Invitation sent successfully',
      invitationId: invitation.id,
    };
  }

  async acceptInvitation(token: string, userId: number) {
    try {
      // 1. Verify JWT token
      const payload = await this.jwtService.verifyAsync(token);
      const { teamId, email, role } = payload;

      // 2. Find invitation in database
      const invitation = await this.prisma.invitation.findUnique({
        where: { token },
      });

      if (
        !invitation ||
        invitation.status === InvitationStatus.ACCEPTED ||
        new Date() > invitation.expiresAt
      ) {
        throw new BadRequestException(
          'Invitation invalid, already accepted or expired',
        );
      }

      // 3. Get current user
      const user = await this.prisma.user.findUnique({ where: { id: userId } });
      if (!user) throw new NotFoundException('User not found');

      // 4. Verify email matches
      if (user.email.toLowerCase() !== email.toLowerCase()) {
        throw new ForbiddenException('Email mismatch for this invitation');
      }

      const userName = user.name ?? 'New Member';

      // 5. Atomic transaction
      await this.prisma.$transaction([
        this.prisma.teamMember.create({
          data: {
            userId,
            teamId,
            role: (role as TeamRole) || TeamRole.MEMBER,
          },
        }),
        this.prisma.invitation.update({
          where: { id: invitation.id },
          data: { status: InvitationStatus.ACCEPTED },
        }),
      ]);

      // 6. Notify via WebSockets
      this.notifications.notifyInvitationAccepted(teamId, userName);

      return { message: 'Joined the team successfully' };
    } catch (error: any) {
      if (error.name === 'JsonWebTokenError')
        throw new BadRequestException('Invalid invitation token');
      if (error.name === 'TokenExpiredError')
        throw new BadRequestException('Invitation token has expired');
      throw error;
    }
  }
}


================================================================================
File: bff-nestjs/src/modules/mail/interfaces/mail-provider.interface.ts
Size: 247 B
================================================================================

// src/modules/mail/interfaces/mail-provider.interface.ts
export interface IMailOptions {
  to: string;
  subject: string;
  template: string;
  context: any;
}

export interface IMailProvider {
  sendMail(options: IMailOptions): Promise<void>;
}


================================================================================
File: bff-nestjs/src/modules/mail/mail.module.ts
Size: 381 B
================================================================================

import { Module } from '@nestjs/common';
import { MailService } from './mail.service';
// import { MailProcessor } from './mail.processor'; // English: Commented to avoid Redis dependency

@Module({
  providers: [
    MailService,
    // MailProcessor // English: Commented to avoid "Worker requires a connection" error
  ],
  exports: [MailService],
})
export class MailModule {}


================================================================================
File: bff-nestjs/src/modules/mail/mail.processor.ts
Size: 916 B
================================================================================

import { Processor, WorkerHost } from '@nestjs/bullmq';
import { Job } from 'bullmq';
import { Logger } from '@nestjs/common';
// English: Corrected path. Since both files are in src/modules/mail/, use './'
import { MailService } from './mail.service';

@Processor('mail-queue')
export class MailProcessor extends WorkerHost {
  private readonly logger = new Logger(MailProcessor.name);

  constructor(private readonly mailService: MailService) {
    super();
  }

  async process(job: Job<any, any, string>): Promise<any> {
    this.logger.log(`Processing job ${job.id} of type ${job.name}...`);

    switch (job.name) {
      case 'send-invitation':
        const { email, token, teamName } = job.data;
        return await this.mailService.sendInvitationEmail(
          email,
          teamName,
          token,
        );

      default:
        this.logger.warn(`Unknown job name: ${job.name}`);
    }
  }
}


================================================================================
File: bff-nestjs/src/modules/mail/mail.service.spec.ts
Size: 745 B
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { MailService } from './mail.service';

describe('MailService', () => {
  let service: MailService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [MailService],
    }).compile();

    service = module.get<MailService>(MailService);
  });

  it('should log and return true when sending invitation', async () => {
    const consoleSpy = jest.spyOn(console, 'log').mockImplementation();
    const result = await service.sendInvitationEmail(
      'test@test.com',
      'Team A',
      'token123',
    );

    expect(result).toBe(true);
    expect(consoleSpy).toHaveBeenCalled();
    consoleSpy.mockRestore();
  });
});


================================================================================
File: bff-nestjs/src/modules/mail/mail.service.ts
Size: 553 B
================================================================================

// En src/modules/mail/mail.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class MailService {
  // constructor(@InjectQueue('mail') private mailQueue: Queue) {} // English: Comment this out

  async sendInvitationEmail(email: string, teamName: string, token: string) {
    // English: Instead of adding to BullMQ queue, we just log it for now
    console.log(
      `[SIMULATED MAIL] Sending invitation to ${email} for team ${teamName}`,
    );
    console.log(`[SIMULATED MAIL] Token: ${token}`);
    return true;
  }
}


================================================================================
File: bff-nestjs/src/modules/mail/providers/nodemailer.provider.ts
Size: 2.07 kB
================================================================================

import { Injectable, Logger } from '@nestjs/common';
import * as nodemailer from 'nodemailer';
import { ConfigService } from '@nestjs/config';
import {
  IMailProvider,
  IMailOptions,
} from '../interfaces/mail-provider.interface';

@Injectable()
export class NodemailerProvider implements IMailProvider {
  private transporter: nodemailer.Transporter;
  private readonly logger = new Logger(NodemailerProvider.name);

  constructor(private config: ConfigService) {
    // English: Initialize the SMTP transporter using environment configuration
    this.transporter = nodemailer.createTransport({
      host: this.config.get<string>('MAIL_HOST'),
      port: this.config.get<number>('MAIL_PORT'),
      auth: {
        user: this.config.get<string>('MAIL_USER'),
        pass: this.config.get<string>('MAIL_PASS'),
      },
    });
  }

  /**
   * English: Sends an email using the configured SMTP transport.
   * Implementation includes strict error handling for production environments.
   */
  async sendMail(options: IMailOptions): Promise<void> {
    try {
      await this.transporter.sendMail({
        from: this.config.get<string>('MAIL_FROM'),
        to: options.to,
        subject: options.subject,
        // English: Basic HTML structure for the email.
        // In the future, this can be integrated with a template engine like EJS or Handlebars.
        html: `<h1>${options.subject}</h1><p>${options.context.message || ''}</p>`,
      });

      this.logger.log(`Email successfully sent to ${options.to}`);
    } catch (error: unknown) {
      // English: Type Guard to safely handle 'unknown' error type (TS18046)
      const errorMessage =
        error instanceof Error ? error.message : 'An unknown error occurred';
      const errorStack = error instanceof Error ? error.stack : undefined;

      this.logger.error(
        `Failed to send email to ${options.to}: ${errorMessage}`,
        errorStack,
      );

      // English: Rethrow the error after logging to allow the caller or BullMQ to handle retries
      throw error;
    }
  }
}


================================================================================
File: bff-nestjs/src/modules/notifications/notifications.gateway.spec.ts
Size: 2.39 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { NotificationsGateway } from './notifications.gateway';
import { JwtService } from '@nestjs/jwt';
import { Socket, Server } from 'socket.io';

describe('NotificationsGateway', () => {
  let gateway: NotificationsGateway;

  // English: Mocking the Socket.io Server and Socket
  const mockServer = {
    to: jest.fn().mockReturnThis(),
    emit: jest.fn(),
  };

  const mockSocket = {
    id: 'socket_123',
    join: jest.fn(),
  } as unknown as Socket;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        NotificationsGateway,
        { provide: JwtService, useValue: {} }, // Mock simple para el Guard
      ],
    }).compile();

    gateway = module.get<NotificationsGateway>(NotificationsGateway);
    // English: Manually inject the mocked server into the gateway
    gateway.server = mockServer as unknown as Server;
  });

  it('should be defined', () => {
    expect(gateway).toBeDefined();
  });

  describe('handleJoinTeam', () => {
    it('should join the correct team room', () => {
      const teamId = 5;
      gateway.handleJoinTeam(teamId, mockSocket);

      expect(mockSocket.join).toHaveBeenCalledWith(`team_${teamId}`);
    });
  });

  describe('notifyInvitationAccepted', () => {
    it('should emit INVITATION_ACCEPTED to the specific team room', () => {
      const teamId = 10;
      const userName = 'Alice';

      gateway.notifyInvitationAccepted(teamId, userName);

      // English: Verify it targets the correct room
      expect(mockServer.to).toHaveBeenCalledWith(`team_${teamId}`);
      // English: Verify the payload structure
      expect(mockServer.emit).toHaveBeenCalledWith('notification', {
        type: 'INVITATION_ACCEPTED',
        message: `${userName} has joined the team!`,
      });
    });
  });

  describe('notifyTaskUpdate', () => {
    it('should emit TASK_UPDATE with the correct action', () => {
      const teamId = 1;
      const taskTitle = 'Fix Bug';
      const action = 'completed';

      gateway.notifyTaskUpdate(teamId, taskTitle, action);

      expect(mockServer.to).toHaveBeenCalledWith(`team_${teamId}`);
      expect(mockServer.emit).toHaveBeenCalledWith('notification', {
        type: 'TASK_UPDATE',
        message: `Task "${taskTitle}" was completed`,
      });
    });
  });
});


================================================================================
File: bff-nestjs/src/modules/notifications/notifications.gateway.ts
Size: 1.28 kB
================================================================================

import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  MessageBody,
  ConnectedSocket,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { UseGuards, Logger } from '@nestjs/common';
import { WsJwtGuard } from '../../auth/guards/ws-jwt.guard';

@WebSocketGateway({
  cors: { origin: '*' },
  namespace: 'notifications',
})
export class NotificationsGateway {
  @WebSocketServer() server!: Server;
  private readonly logger = new Logger(NotificationsGateway.name);

  // English: Client joins a specific room for their team
  @SubscribeMessage('joinTeam')
  handleJoinTeam(
    @MessageBody('teamId') teamId: number,
    @ConnectedSocket() client: Socket,
  ) {
    const room = `team_${teamId}`;
    client.join(room);
    this.logger.log(`Client ${client.id} joined room: ${room}`);
  }

  notifyInvitationAccepted(teamId: number, userName: string) {
    this.server.to(`team_${teamId}`).emit('notification', {
      type: 'INVITATION_ACCEPTED',
      message: `${userName} has joined the team!`,
    });
  }

  notifyTaskUpdate(teamId: number, taskTitle: string, action: string) {
    this.server.to(`team_${teamId}`).emit('notification', {
      type: 'TASK_UPDATE',
      message: `Task "${taskTitle}" was ${action}`,
    });
  }
}


================================================================================
File: bff-nestjs/src/modules/notifications/notifications.module.ts
Size: 448 B
================================================================================

import { Module, Global } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt'; // Requerido para WsJwtGuard
import { NotificationsGateway } from './notifications.gateway';

@Global()
@Module({
  imports: [
    // English: We import JwtModule to allow JwtService to be injected into WsJwtGuard
    JwtModule.register({}),
  ],
  providers: [NotificationsGateway],
  exports: [NotificationsGateway],
})
export class NotificationsModule {}


================================================================================
File: bff-nestjs/src/modules/projects/dto/create-project.dto.ts
Size: 503 B
================================================================================

import {
  IsNotEmpty,
  IsString,
  MinLength,
  IsOptional,
  MaxLength,
} from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateProjectDto {
  @ApiProperty({ example: 'Marketing Campaign', minLength: 3 })
  @IsString()
  @IsNotEmpty()
  @MinLength(3)
  @MaxLength(100)
  name!: string;

  @ApiPropertyOptional({ example: 'Project focused on Q1 social media growth' })
  @IsString()
  @IsOptional()
  @MaxLength(500)
  description?: string;
}


================================================================================
File: bff-nestjs/src/modules/projects/projects.controller.spec.ts
Size: 1.55 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { ProjectsController } from './projects.controller';
import { ProjectsService } from './projects.service';
import { PrismaService } from '../../prisma/prisma.service';
import { Reflector } from '@nestjs/core';
import { Role } from '@prisma/client';

describe('ProjectsController', () => {
  let controller: ProjectsController;
  let service: ProjectsService;

  const mockProjectsService = {
    create: jest.fn(),
    findAllByTeam: jest.fn(),
    remove: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ProjectsController],
      providers: [
        { provide: ProjectsService, useValue: mockProjectsService },
        { provide: PrismaService, useValue: {} }, // Mock vac√≠o para el guard
        Reflector,
      ],
    }).compile();

    controller = module.get<ProjectsController>(ProjectsController);
    service = module.get<ProjectsService>(ProjectsService);
  });

  it('should call create service', async () => {
    const dto = { name: 'Test Project' } as any;
    await controller.create(1, dto);
    expect(service.create).toHaveBeenCalledWith(1, dto);
  });

  it('should call findAll service', async () => {
    await controller.findAll(1);
    expect(service.findAllByTeam).toHaveBeenCalledWith(1);
  });

  it('should call remove service', async () => {
    await controller.remove(1, 100, 1, Role.USER);
    expect(service.remove).toHaveBeenCalledWith(1, 100, Role.USER);
  });
});


================================================================================
File: bff-nestjs/src/modules/projects/projects.controller.ts
Size: 1.56 kB
================================================================================

import {
  Controller,
  Post,
  Get,
  Delete,
  Body,
  Param,
  ParseIntPipe,
  UseGuards,
} from '@nestjs/common';
import { ProjectsService } from './projects.service';
import { CreateProjectDto } from './dto/create-project.dto';
import { RolesGuard } from '../../common/guards/roles.guard';
import { GetCurrentUserId, GetCurrentUserRole } from '../../common/decorators';
import { Role, TeamRole } from '@prisma/client';
import {
  ApiTags,
  ApiOperation,
  ApiBearerAuth,
  ApiResponse,
} from '@nestjs/swagger';

@ApiTags('Projects')
@ApiBearerAuth('access-token')
@Controller('teams/:teamId/projects')
@UseGuards(RolesGuard)
export class ProjectsController {
  constructor(private projectsService: ProjectsService) {}

  @Post()
  @ApiOperation({ summary: 'Create a new project' })
  create(
    @Param('teamId', ParseIntPipe) teamId: number,
    @Body() dto: CreateProjectDto,
  ) {
    return this.projectsService.create(teamId, dto);
  }

  @Get()
  @ApiOperation({ summary: 'List team projects' })
  findAll(@Param('teamId', ParseIntPipe) teamId: number) {
    return this.projectsService.findAllByTeam(teamId);
  }

  @Delete(':projectId')
  @ApiOperation({ summary: 'Soft-delete a project' })
  remove(
    @Param('teamId', ParseIntPipe) teamId: number,
    @Param('projectId', ParseIntPipe) projectId: number,
    @GetCurrentUserId() userId: number,
    @GetCurrentUserRole() userRole: Role,
  ) {
    // Note: teamRole should be extracted from request.user if needed
    return this.projectsService.remove(teamId, projectId, userRole);
  }
}


================================================================================
File: bff-nestjs/src/modules/projects/projects.module.ts
Size: 403 B
================================================================================

import { Module } from '@nestjs/common';
import { ProjectsService } from './projects.service';
import { ProjectsController } from './projects.controller';
import { PrismaModule } from '../../prisma/prisma.module'; // Path corrected

@Module({
  imports: [PrismaModule],
  controllers: [ProjectsController],
  providers: [ProjectsService],
  exports: [ProjectsService],
})
export class ProjectsModule {}


================================================================================
File: bff-nestjs/src/modules/projects/projects.service.spec.ts
Size: 3.27 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { ProjectsService } from './projects.service';
import { PrismaService } from '../../prisma/prisma.service';
import { NotFoundException, ForbiddenException } from '@nestjs/common';
import { Role, TeamRole } from '@prisma/client';

describe('ProjectsService', () => {
  let service: ProjectsService;
  let prisma: PrismaService;

  const mockPrisma = {
    extended: {
      team: { findUnique: jest.fn() },
      project: {
        create: jest.fn(),
        findMany: jest.fn(),
        findFirst: jest.fn(),
        softDelete: jest.fn(),
      },
    },
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ProjectsService,
        { provide: PrismaService, useValue: mockPrisma },
      ],
    }).compile();

    service = module.get<ProjectsService>(ProjectsService);
    prisma = module.get<PrismaService>(PrismaService);
  });

  describe('create', () => {
    it('should throw NotFound if team does not exist', async () => {
      (mockPrisma.extended.team.findUnique as jest.Mock).mockResolvedValue(
        null,
      );
      await expect(service.create(1, { name: 'P1' } as any)).rejects.toThrow(
        NotFoundException,
      );
    });

    it('should create a project if team exists', async () => {
      (mockPrisma.extended.team.findUnique as jest.Mock).mockResolvedValue({
        id: 1,
      });
      (mockPrisma.extended.project.create as jest.Mock).mockResolvedValue({
        id: 101,
        name: 'P1',
      });
      const result = await service.create(1, { name: 'P1' } as any);
      expect(result.id).toBe(101);
    });
  });

  describe('findAllByTeam', () => {
    it('should return many projects', async () => {
      (mockPrisma.extended.project.findMany as jest.Mock).mockResolvedValue([
        { id: 1 },
      ]);
      const result = await service.findAllByTeam(1);
      expect(result).toHaveLength(1);
    });
  });

  describe('remove', () => {
    it('should throw NotFound if project not found', async () => {
      (mockPrisma.extended.project.findFirst as jest.Mock).mockResolvedValue(
        null,
      );
      await expect(service.remove(1, 99, Role.ADMIN)).rejects.toThrow(
        NotFoundException,
      );
    });

    it('should throw Forbidden if user is not Admin and not Owner', async () => {
      (mockPrisma.extended.project.findFirst as jest.Mock).mockResolvedValue({
        id: 99,
      });
      await expect(
        service.remove(1, 99, Role.USER, TeamRole.MEMBER),
      ).rejects.toThrow(ForbiddenException);
    });

    it('should allow deletion if user is ADMIN', async () => {
      (mockPrisma.extended.project.findFirst as jest.Mock).mockResolvedValue({
        id: 99,
      });
      await service.remove(1, 99, Role.ADMIN);
      expect(mockPrisma.extended.project.softDelete).toHaveBeenCalledWith(99);
    });

    it('should allow deletion if user is Team OWNER', async () => {
      (mockPrisma.extended.project.findFirst as jest.Mock).mockResolvedValue({
        id: 99,
      });
      await service.remove(1, 99, Role.USER, TeamRole.OWNER);
      expect(mockPrisma.extended.project.softDelete).toHaveBeenCalledWith(99);
    });
  });
});


================================================================================
File: bff-nestjs/src/modules/projects/projects.service.ts
Size: 1.85 kB
================================================================================

import {
  Injectable,
  ForbiddenException,
  NotFoundException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CreateProjectDto } from './dto/create-project.dto';
import { Role, TeamRole } from '@prisma/client';

@Injectable()
export class ProjectsService {
  private readonly logger = new Logger(ProjectsService.name);

  constructor(private prisma: PrismaService) {}

  async create(teamId: number, dto: CreateProjectDto) {
    // English: The RolesGuard already verified membership.
    // We only check if the team exists to be safe.
    const team = await this.prisma.extended.team.findUnique({
      where: { id: teamId },
    });

    if (!team) throw new NotFoundException(`Team with ID ${teamId} not found`);

    return this.prisma.extended.project.create({
      data: {
        ...dto,
        teamId: teamId,
      },
    });
  }

  async findAllByTeam(teamId: number) {
    // English: Guard already checked access. Just return projects.
    return this.prisma.extended.project.findMany({
      where: { teamId },
      include: {
        _count: { select: { tasks: true } },
      },
    });
  }

  async remove(
    teamId: number,
    projectId: number,
    userRole: Role,
    teamRole?: TeamRole,
  ) {
    const project = await this.prisma.extended.project.findFirst({
      where: { id: projectId, teamId },
    });

    if (!project) throw new NotFoundException('Project not found in this team');

    // English: Hierarchy check: Only Global Admin or Team Owner can delete
    const canDelete = userRole === Role.ADMIN || teamRole === TeamRole.OWNER;

    if (!canDelete) {
      throw new ForbiddenException(
        'Only Team Owners or Admins can delete projects',
      );
    }

    return (this.prisma.extended.project as any).softDelete(projectId);
  }
}


================================================================================
File: bff-nestjs/src/modules/tasks/attachments.service.spec.ts
Size: 7.62 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { AttachmentsService } from './attachments.service';
import { PrismaService } from '../../prisma/prisma.service';
import { StorageService } from '../../storage/storage.service';
import {
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common';

describe('AttachmentsService', () => {
  let service: AttachmentsService;
  let prisma: PrismaService;
  let storage: StorageService;

  const mockAttachment = {
    id: 1,
    filename: 'test.jpg',
    url: 'https://iaqnnevdkhpkpyrwecfh.storage.supabase.co/storage/v1/s3/attachments/task-attachments/1769252065725-test.jpg',
    taskId: 101,
    mimetype: 'image/jpeg',
    size: 1024,
    createdAt: new Date('2026-01-24T10:54:26.899Z'),
    updatedAt: new Date('2026-01-24T10:54:26.899Z'),
    deletedAt: null as Date | null,
  };

  const mockStorageService = {
    deleteFile: jest.fn().mockResolvedValue(undefined),
  };

  const mockPrismaService = {
    extended: {
      attachment: {
        create: jest.fn().mockResolvedValue(mockAttachment),
        findFirst: jest.fn(),
      },
    },
    // English: Use standard attachment for write operations (not extended)
    attachment: {
      update: jest.fn().mockResolvedValue({
        ...mockAttachment,
        deletedAt: new Date('2026-01-24T12:26:16.240Z'),
        updatedAt: new Date('2026-01-24T12:26:16.242Z'),
      }),
    },
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AttachmentsService,
        { provide: StorageService, useValue: mockStorageService },
        { provide: PrismaService, useValue: mockPrismaService },
      ],
    }).compile();

    service = module.get<AttachmentsService>(AttachmentsService);
    prisma = module.get<PrismaService>(PrismaService);
    storage = module.get<StorageService>(StorageService);

    // English: Reset all mocks before each test
    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create', () => {
    it('should create an attachment successfully', async () => {
      const fileData = {
        filename: 'test.jpg',
        url: mockAttachment.url,
        mimetype: 'image/jpeg',
        size: 1024,
      };

      const result = await service.create(101, fileData);

      expect(mockPrismaService.extended.attachment.create).toHaveBeenCalledWith(
        {
          data: {
            ...fileData,
            taskId: 101,
          },
        },
      );
      expect(result).toEqual(mockAttachment);
    });
  });

  describe('findOne', () => {
    it('should return an attachment when found', async () => {
      (
        mockPrismaService.extended.attachment.findFirst as jest.Mock
      ).mockResolvedValue(mockAttachment);

      const result = await service.findOne(1);

      expect(
        mockPrismaService.extended.attachment.findFirst,
      ).toHaveBeenCalledWith({
        where: {
          id: 1,
          deletedAt: null,
        },
      });
      expect(result).toEqual(mockAttachment);
    });

    it('should throw NotFoundException when attachment not found', async () => {
      (
        mockPrismaService.extended.attachment.findFirst as jest.Mock
      ).mockResolvedValue(null);

      await expect(service.findOne(999)).rejects.toThrow(NotFoundException);
    });

    it('should throw NotFoundException when attachment is soft-deleted', async () => {
      (
        mockPrismaService.extended.attachment.findFirst as jest.Mock
      ).mockResolvedValue(null);

      await expect(service.findOne(1)).rejects.toThrow(
        'Attachment with ID 1 not found',
      );
    });
  });

  describe('remove', () => {
    it('should perform soft delete in database regardless of storage errors', async () => {
      // English: Mock findOne to return the attachment
      (
        mockPrismaService.extended.attachment.findFirst as jest.Mock
      ).mockResolvedValue(mockAttachment);

      // English: Mock storage error - should not prevent soft delete
      (mockStorageService.deleteFile as jest.Mock).mockRejectedValue(
        new Error('Storage service error'),
      );

      const result = await service.remove(1);

      // English: Verify soft delete was executed despite storage error
      expect(mockPrismaService.attachment.update).toHaveBeenCalledWith({
        where: { id: 1 },
        data: { deletedAt: expect.any(Date) },
      });

      // English: Verify deletion from storage was attempted
      expect(mockStorageService.deleteFile).toHaveBeenCalledWith(
        mockAttachment.url,
      );

      // English: Verify soft delete result is returned
      expect(result.deletedAt).toBeDefined();
      expect(result.deletedAt).not.toBeNull();
    });

    it('should successfully soft-delete and delete from storage', async () => {
      // English: Mock both operations succeeding
      (
        mockPrismaService.extended.attachment.findFirst as jest.Mock
      ).mockResolvedValue(mockAttachment);

      const result = await service.remove(1);

      // English: Verify database update
      expect(mockPrismaService.attachment.update).toHaveBeenCalledWith({
        where: { id: 1 },
        data: { deletedAt: expect.any(Date) },
      });

      // English: Verify storage deletion was called
      expect(mockStorageService.deleteFile).toHaveBeenCalledWith(
        mockAttachment.url,
      );

      // English: Verify the result has deletedAt populated
      expect(result).toEqual(
        expect.objectContaining({
          id: 1,
          deletedAt: expect.any(Date),
        }),
      );
    });

    it('should throw InternalServerErrorException if database update fails', async () => {
      (
        mockPrismaService.extended.attachment.findFirst as jest.Mock
      ).mockResolvedValue(mockAttachment);

      (mockPrismaService.attachment.update as jest.Mock).mockRejectedValue(
        new Error('Database error'),
      );

      await expect(service.remove(1)).rejects.toThrow(
        InternalServerErrorException,
      );
    });

    it('should throw NotFoundException if attachment does not exist', async () => {
      (
        mockPrismaService.extended.attachment.findFirst as jest.Mock
      ).mockResolvedValue(null);

      await expect(service.remove(999)).rejects.toThrow(NotFoundException);
    });

    it('should log warning but not throw if storage deletion fails', async () => {
      const loggerSpy = jest.spyOn(service['logger'], 'warn');

      // English: Setup mocks
      (
        mockPrismaService.extended.attachment.findFirst as jest.Mock
      ).mockResolvedValue(mockAttachment);

      // English: Make storage deletion fail
      (mockStorageService.deleteFile as jest.Mock).mockRejectedValue(
        new Error('Storage connection timeout'),
      );

      // English: Make database update succeed
      const softDeletedAttachment = {
        ...mockAttachment,
        deletedAt: new Date('2026-01-24T12:26:16.240Z'),
        updatedAt: new Date('2026-01-24T12:26:16.242Z'),
      };
      (mockPrismaService.attachment.update as jest.Mock).mockResolvedValue(
        softDeletedAttachment,
      );

      const result = await service.remove(1);

      // English: Verify soft delete completed successfully
      expect(result.deletedAt).toBeDefined();
      expect(result.id).toBe(1);

      // English: Verify warning was logged for storage error
      expect(loggerSpy).toHaveBeenCalledWith(
        expect.stringContaining('Failed to delete attachment'),
      );
    });
  });
});


================================================================================
File: bff-nestjs/src/modules/tasks/attachments.service.ts
Size: 2.74 kB
================================================================================

import {
  Injectable,
  Logger,
  NotFoundException,
  InternalServerErrorException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { StorageService } from '../../storage/storage.service';

@Injectable()
export class AttachmentsService {
  private readonly logger = new Logger(AttachmentsService.name);

  constructor(
    private prisma: PrismaService,
    private storageService: StorageService,
  ) {}

  async create(
    taskId: number,
    fileData: { filename: string; url: string; mimetype: string; size: number },
  ) {
    this.logger.log(`Attaching file ${fileData.filename} to task ${taskId}`);
    return this.prisma.extended.attachment.create({
      data: {
        ...fileData,
        taskId,
      },
    });
  }

  async findOne(id: number) {
    // English: findFirst is required because findUnique doesn't support filtering by non-unique 'deletedAt'
    const attachment = await this.prisma.extended.attachment.findFirst({
      where: {
        id,
        deletedAt: null,
      },
    });

    if (!attachment) {
      throw new NotFoundException(`Attachment with ID ${id} not found`);
    }

    return attachment;
  }

  async remove(id: number) {
    const attachment = await this.findOne(id);

    // English: First, perform soft delete in database
    // This ensures data consistency even if storage deletion fails
    try {
      const deletedAttachment = await this.prisma.attachment.update({
        where: { id },
        data: { deletedAt: new Date() },
      });

      this.logger.log(`Soft deleted attachment ${id} from database`);

      // English: Then attempt to delete from cloud storage
      // If this fails, it's logged but doesn't affect the main operation
      try {
        await this.storageService.deleteFile(attachment.url);
        this.logger.log(
          `Successfully deleted attachment ${id} from cloud storage`,
        );
      } catch (storageError: unknown) {
        const errorMessage =
          storageError instanceof Error
            ? storageError.message
            : 'Unknown error';
        this.logger.warn(
          `Failed to delete attachment ${id} from storage (soft delete completed): ${errorMessage}`,
        );
        // English: Don't throw - soft delete in DB is the priority
        // Storage deletion can be retried manually if needed
      }

      return deletedAttachment;
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`Error deleting attachment ${id}: ${errorMessage}`);
      throw new InternalServerErrorException(
        'Failed to remove attachment from database',
      );
    }
  }
}


================================================================================
File: bff-nestjs/src/modules/tasks/dto/create-task.dto.ts
Size: 1.31 kB
================================================================================

import {
  IsNotEmpty,
  IsString,
  IsOptional,
  IsInt,
  IsDateString,
  IsEnum,
} from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { TaskStatus } from '@prisma/client';

export class CreateTaskDto {
  @ApiProperty({
    example: 'Implement Login UI',
    description: 'The title of the task',
  })
  @IsString()
  @IsNotEmpty()
  title!: string;

  @ApiPropertyOptional({
    example: 'Create the frontend form for user authentication',
    description: 'Detailed description of the task',
  })
  @IsString()
  @IsOptional()
  description?: string;

  @ApiPropertyOptional({
    enum: TaskStatus,
    example: TaskStatus.TODO,
    description: 'The current status of the task',
  })
  @IsEnum(TaskStatus)
  @IsOptional()
  status?: TaskStatus = TaskStatus.TODO;

  @ApiProperty({
    example: 1,
    description: 'The ID of the project this task belongs to',
  })
  @IsInt()
  @IsNotEmpty()
  projectId!: number;

  @ApiPropertyOptional({
    example: 5,
    description: 'The ID of the user assigned to this task',
  })
  @IsInt()
  @IsOptional()
  assigneeId?: number;

  @ApiPropertyOptional({
    example: '2026-02-01T00:00:00.000Z',
    description: 'Due date for the task in ISO 8601 format',
  })
  @IsDateString()
  @IsOptional()
  dueDate?: string;
}


================================================================================
File: bff-nestjs/src/modules/tasks/tasks.controller.spec.ts
Size: 3.67 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { TasksController } from './tasks.controller';
import { TasksService } from './tasks.service';
import { StorageService } from '../../storage/storage.service';
import { CreateTaskDto } from './dto/create-task.dto';
import { TaskStatus } from '@prisma/client';

describe('TasksController', () => {
  let controller: TasksController;
  let tasksService: TasksService;
  let storageService: StorageService;

  const mockUserId = 1;

  // English: Comprehensive mocks for all services used in the controller
  const mockTasksService = {
    create: jest.fn(),
    findAllByProject: jest.fn(),
    addAttachment: jest.fn(),
    removeAttachment: jest.fn(),
  };

  const mockStorageService = {
    uploadFile: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [TasksController],
      providers: [
        { provide: TasksService, useValue: mockTasksService },
        { provide: StorageService, useValue: mockStorageService },
      ],
    }).compile();

    controller = module.get<TasksController>(TasksController);
    tasksService = module.get<TasksService>(TasksService);
    storageService = module.get<StorageService>(StorageService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('create', () => {
    it('should call tasksService.create with userId and dto', async () => {
      const dto: CreateTaskDto = {
        title: 'New Task',
        projectId: 1,
        status: TaskStatus.TODO,
      };
      mockTasksService.create.mockResolvedValue({ id: 1, ...dto });

      const result = await controller.create(mockUserId, dto);

      expect(tasksService.create).toHaveBeenCalledWith(mockUserId, dto);
      expect(result).toHaveProperty('id');
    });
  });

  describe('findAll', () => {
    it('should call tasksService.findAllByProject with correct params', async () => {
      const projectId = 10;
      mockTasksService.findAllByProject.mockResolvedValue([]);

      await controller.findAll(projectId, mockUserId);

      expect(tasksService.findAllByProject).toHaveBeenCalledWith(
        mockUserId,
        projectId,
      );
    });
  });

  describe('uploadFile', () => {
    it('should upload to storage and then add attachment to DB', async () => {
      const taskId = 123;
      const mockFile = {
        originalname: 'test.png',
        mimetype: 'image/png',
        size: 5000,
        buffer: Buffer.from(''),
      } as Express.Multer.File;

      const mockUrl = 'http://cloud.storage/test.png';
      mockStorageService.uploadFile.mockResolvedValue(mockUrl);
      mockTasksService.addAttachment.mockResolvedValue({ id: 1, url: mockUrl });

      const result = await controller.uploadFile(taskId, mockFile);

      // English: Verify the sequential flow: Storage first, then DB
      expect(storageService.uploadFile).toHaveBeenCalledWith(mockFile);
      expect(tasksService.addAttachment).toHaveBeenCalledWith(taskId, {
        filename: mockFile.originalname,
        url: mockUrl,
        mimetype: mockFile.mimetype,
        size: mockFile.size,
      });
      expect(result.url).toBe(mockUrl);
    });
  });

  describe('removeAttachment', () => {
    it('should call tasksService.removeAttachment', async () => {
      const attachmentId = 99;
      mockTasksService.removeAttachment.mockResolvedValue({ success: true });

      await controller.removeAttachment(attachmentId);

      expect(tasksService.removeAttachment).toHaveBeenCalledWith(attachmentId);
    });
  });
});


================================================================================
File: bff-nestjs/src/modules/tasks/tasks.controller.ts
Size: 2.75 kB
================================================================================

import {
  Controller,
  Post,
  Body,
  Get,
  Param,
  ParseIntPipe,
  Delete,
  UseInterceptors,
  UploadedFile,
  ParseFilePipe,
  MaxFileSizeValidator,
  FileTypeValidator,
  UseGuards,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import {
  ApiTags,
  ApiOperation,
  ApiBearerAuth,
  ApiConsumes,
  ApiBody,
} from '@nestjs/swagger';
import { TasksService } from './tasks.service';
import { CreateTaskDto } from './dto/create-task.dto';
import { StorageService } from '../../storage/storage.service';
import { AtGuard } from '../../auth/guards/at.guard';
import { GetCurrentUserId } from '../../common/decorators';

@ApiTags('Tasks')
@ApiBearerAuth('access-token')
@UseGuards(AtGuard)
@Controller('tasks')
export class TasksController {
  constructor(
    private readonly tasksService: TasksService,
    private readonly storageService: StorageService,
  ) {}

  @Post()
  @ApiOperation({ summary: 'Create a new task' })
  async create(@GetCurrentUserId() userId: number, @Body() dto: CreateTaskDto) {
    // English: The service validates if the userId has access to the project's team
    return this.tasksService.create(userId, dto);
  }

  @Get('project/:projectId')
  @ApiOperation({ summary: 'Get all tasks for a project' })
  async findAll(
    @Param('projectId', ParseIntPipe) projectId: number,
    @GetCurrentUserId() userId: number,
  ) {
    return this.tasksService.findAllByProject(userId, projectId);
  }

  @Post(':id/upload')
  @ApiOperation({ summary: 'Upload an attachment to a task' })
  @ApiConsumes('multipart/form-data')
  @ApiBody({
    schema: {
      type: 'object',
      properties: { file: { type: 'string', format: 'binary' } },
    },
  })
  @UseInterceptors(FileInterceptor('file'))
  async uploadFile(
    @Param('id', ParseIntPipe) taskId: number,
    @UploadedFile(
      new ParseFilePipe({
        validators: [
          new MaxFileSizeValidator({ maxSize: 1024 * 1024 * 5 }), // 5MB limit
          new FileTypeValidator({ fileType: /(jpg|jpeg|png|pdf|zip)$/ }),
        ],
      }),
    )
    file: Express.Multer.File,
  ) {
    // English: First upload to cloud storage, then save record in DB
    const fileUrl = await this.storageService.uploadFile(file);
    return this.tasksService.addAttachment(taskId, {
      filename: file.originalname,
      url: fileUrl,
      mimetype: file.mimetype,
      size: file.size,
    });
  }

  @Delete('attachments/:attachmentId')
  @ApiOperation({ summary: 'Remove an attachment from a task' })
  async removeAttachment(
    @Param('attachmentId', ParseIntPipe) attachmentId: number,
  ) {
    // English: Deletes from both storage provider and database
    return this.tasksService.removeAttachment(attachmentId);
  }
}


================================================================================
File: bff-nestjs/src/modules/tasks/tasks.module.ts
Size: 650 B
================================================================================

// src/modules/tasks/tasks.module.ts
import { Module } from '@nestjs/common';
import { TasksService } from './tasks.service';
import { TasksController } from './tasks.controller';
import { StorageModule } from '../../storage/storage.module';
import { NotificationsModule } from '../notifications/notifications.module';
import { AttachmentsService } from './attachments.service'; // <--- Importaci√≥n a√±adida

@Module({
  imports: [StorageModule, NotificationsModule],
  controllers: [TasksController],
  providers: [
    TasksService,
    AttachmentsService, // <--- Proveedor a√±adido
  ],
  exports: [TasksService],
})
export class TasksModule {}


================================================================================
File: bff-nestjs/src/modules/tasks/tasks.service.int-spec.ts
Size: 3.18 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { TasksService } from './tasks.service';
import { PrismaService } from '../../prisma/prisma.service';
import { NotificationsGateway } from '../notifications/notifications.gateway';
import { StorageService } from '../../storage/storage.service';
import { ConfigModule } from '@nestjs/config';
import { TaskStatus } from '@prisma/client';

describe('TasksService (Integration)', () => {
  let service: TasksService;
  let prisma: PrismaService;

  // English: Mocks for external dependencies to focus on DB integration
  const mockNotifications = {
    notifyTaskUpdate: jest.fn(),
  };

  const mockStorage = {
    deleteFile: jest.fn().mockResolvedValue(true),
  };

  beforeAll(async () => {
    const module: TestingModule = await Test.createTestingModule({
      imports: [ConfigModule.forRoot({ isGlobal: true })],
      providers: [
        TasksService,
        PrismaService,
        { provide: NotificationsGateway, useValue: mockNotifications },
        { provide: StorageService, useValue: mockStorage },
      ],
    }).compile();

    service = module.get<TasksService>(TasksService);
    prisma = module.get<PrismaService>(PrismaService);
  });

  afterEach(async () => {
    // English: Clean up database state after each test
    await prisma.task.deleteMany();
    await prisma.project.deleteMany();
    await prisma.teamMember.deleteMany();
    await prisma.team.deleteMany();
    await prisma.user.deleteMany();
  });

  it('should create a task only if user has permission (is team member)', async () => {
    // 1. Arrange
    const user = await prisma.user.create({
      data: { email: 'dev@test.com', password: 'hash', name: 'Developer' },
    });

    const team = await prisma.team.create({
      data: { name: 'Dev Team' },
    });

    // Link user to team
    await prisma.teamMember.create({
      data: { userId: user.id, teamId: team.id, role: 'MEMBER' },
    });

    const project = await prisma.project.create({
      data: { name: 'New Project', teamId: team.id },
    });

    const dto = {
      title: 'Integrated Task',
      description: 'Test description',
      status: TaskStatus.TODO,
      projectId: project.id,
      assigneeId: user.id,
    };

    // 2. Act
    const task = await service.create(user.id, dto);

    // 3. Assert
    expect(task).toBeDefined();
    expect(task.title).toBe(dto.title);
    expect(mockNotifications.notifyTaskUpdate).toHaveBeenCalled();
  });

  it('should throw ForbiddenException if user is NOT in the team', async () => {
    // 1. Arrange: Create user and project but don't link them
    const stranger = await prisma.user.create({
      data: { email: 'stranger@test.com', password: 'hash' },
    });

    const team = await prisma.team.create({ data: { name: 'Private Team' } });
    const project = await prisma.project.create({
      data: { name: 'Private Project', teamId: team.id },
    });

    const dto = { title: 'Illegal Task', projectId: project.id };

    // 2. Act & Assert
    await expect(service.create(stranger.id, dto as any)).rejects.toThrow(
      'No permission to add tasks to this project',
    );
  });
});


================================================================================
File: bff-nestjs/src/modules/tasks/tasks.service.spec.ts
Size: 4.97 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { TasksService } from './tasks.service';
import { PrismaService } from '../../prisma/prisma.service';
import { NotificationsGateway } from '../notifications/notifications.gateway';
import { StorageService } from '../../storage/storage.service';
import { AttachmentsService } from './attachments.service';
import {
  NotFoundException,
  ForbiddenException,
  InternalServerErrorException,
} from '@nestjs/common';

describe('TasksService', () => {
  let service: TasksService;
  let prisma: PrismaService;
  let storageService: StorageService;
  let notifications: NotificationsGateway;
  let attachmentsService: AttachmentsService;

  const mockPrisma = {
    extended: {
      project: { findUnique: jest.fn(), findFirst: jest.fn() },
      task: { create: jest.fn(), findUnique: jest.fn(), findMany: jest.fn() },
    },
  };

  const mockNotifications = { notifyTaskUpdate: jest.fn() };
  const mockStorageService = { deleteFile: jest.fn() };
  const mockAttachmentsService = {
    create: jest.fn(),
    findOne: jest.fn(),
    remove: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TasksService,
        { provide: PrismaService, useValue: mockPrisma },
        { provide: NotificationsGateway, useValue: mockNotifications },
        { provide: StorageService, useValue: mockStorageService },
        { provide: AttachmentsService, useValue: mockAttachmentsService },
      ],
    }).compile();

    service = module.get<TasksService>(TasksService);
    prisma = module.get<PrismaService>(PrismaService);
    storageService = module.get<StorageService>(StorageService);
    notifications = module.get<NotificationsGateway>(NotificationsGateway);
    attachmentsService = module.get<AttachmentsService>(AttachmentsService);
    jest.clearAllMocks();
  });

  describe('create', () => {
    it('should throw ForbiddenException if user is not a member (Line 35)', async () => {
      mockPrisma.extended.project.findUnique.mockResolvedValue({
        team: { members: [] },
      });
      await expect(service.create(1, { projectId: 1 } as any)).rejects.toThrow(
        ForbiddenException,
      );
    });

    it('should handle notification failure (Line 47-51)', async () => {
      mockPrisma.extended.project.findUnique.mockResolvedValue({
        teamId: 1,
        team: { members: [{ userId: 1 }] },
      });
      mockPrisma.extended.task.create.mockResolvedValue({
        id: 1,
        title: 'Test',
      });
      mockNotifications.notifyTaskUpdate.mockImplementation(() => {
        throw new Error();
      });

      const result = await service.create(1, {
        projectId: 1,
        title: 'Test',
      } as any);
      expect(result).toBeDefined();
    });
  });

  describe('addAttachment', () => {
    it('should throw NotFoundException if task not found (Line 76)', async () => {
      mockPrisma.extended.task.findUnique.mockResolvedValue(null);
      await expect(service.addAttachment(999, {} as any)).rejects.toThrow(
        NotFoundException,
      );
    });

    it('should call attachmentsService.create if task exists', async () => {
      mockPrisma.extended.task.findUnique.mockResolvedValue({ id: 1 });
      await service.addAttachment(1, { url: 'test' } as any);
      expect(attachmentsService.create).toHaveBeenCalled();
    });
  });

  describe('removeAttachment', () => {
    it('should handle generic error in catch and log it (Line 89)', async () => {
      mockAttachmentsService.findOne.mockResolvedValue({
        id: 1,
        url: 'http://test.com/file.png',
      });
      // English: Using a real Error object to hit the 'error instanceof Error' branch on line 89
      mockStorageService.deleteFile.mockRejectedValue(new Error('S3 Fail'));

      await expect(service.removeAttachment(1)).rejects.toThrow(
        InternalServerErrorException,
      );
    });

    it('should handle non-Error objects in catch (Lines 90-93)', async () => {
      mockAttachmentsService.findOne.mockResolvedValue({ url: 'url' });
      mockStorageService.deleteFile.mockRejectedValue('Fatal String Error');
      await expect(service.removeAttachment(1)).rejects.toThrow(
        InternalServerErrorException,
      );
    });
  });

  describe('findAllByProject', () => {
    it('should throw ForbiddenException if project access denied', async () => {
      mockPrisma.extended.project.findFirst.mockResolvedValue(null);
      await expect(service.findAllByProject(1, 1)).rejects.toThrow(
        ForbiddenException,
      );
    });

    it('should return tasks with assignee and attachments', async () => {
      mockPrisma.extended.project.findFirst.mockResolvedValue({ id: 1 });
      mockPrisma.extended.task.findMany.mockResolvedValue([{ id: 1 }]);
      const res = await service.findAllByProject(1, 1);
      expect(res).toHaveLength(1);
    });
  });
});


================================================================================
File: bff-nestjs/src/modules/tasks/tasks.service.ts
Size: 4.76 kB
================================================================================

import {
  Injectable,
  ForbiddenException,
  NotFoundException,
  InternalServerErrorException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CreateTaskDto } from './dto/create-task.dto';
import { NotificationsGateway } from '../notifications/notifications.gateway';
import { StorageService } from '../../storage/storage.service';
import { AttachmentsService } from './attachments.service';

@Injectable()
export class TasksService {
  private readonly logger = new Logger(TasksService.name);

  constructor(
    private prisma: PrismaService,
    private notifications: NotificationsGateway,
    private storageService: StorageService,
    private attachmentsService: AttachmentsService,
  ) {}

  async create(userId: number, dto: CreateTaskDto) {
    // English: Check if project exists and user has access via membership
    const project = await this.prisma.extended.project.findFirst({
      where: {
        id: dto.projectId,
        team: {
          members: {
            some: { userId },
          },
        },
      },
      include: {
        team: true,
      },
    });

    if (!project) {
      throw new ForbiddenException(
        'Project not found or no permission to add tasks',
      );
    }

    const task = await this.prisma.extended.task.create({
      data: {
        title: dto.title,
        description: dto.description,
        status: dto.status,
        projectId: dto.projectId,
        assigneeId: dto.assigneeId,
        dueDate: dto.dueDate ? new Date(dto.dueDate) : null,
      },
    });

    // English: Notify via WebSocket. Wrap in try-catch to prevent main flow failure
    try {
      this.notifications.notifyTaskUpdate(
        project.team.id,
        task.title,
        'created',
      );
    } catch (error) {
      this.logger.warn(
        `Failed to send WebSocket notification for task ${task.id}`,
      );
    }

    return task;
  }

  async addAttachment(
    taskId: number,
    fileData: {
      filename: string;
      url: string;
      mimetype: string;
      size: number;
    },
  ) {
    // English: Ensure the task exists before calling attachment service
    const task = await this.prisma.extended.task.findUnique({
      where: { id: taskId },
    });

    if (!task) {
      throw new NotFoundException('Task not found');
    }

    return this.attachmentsService.create(taskId, fileData);
  }

  async removeAttachment(attachmentId: number) {
    // English: Use delegated service to handle attachment removal
    // This includes both storage deletion and database soft-delete
    return this.attachmentsService.remove(attachmentId);
  }

  async findAllByProject(userId: number, projectId: number) {
    // English: Ensure user is part of the team that owns the project
    const project = await this.prisma.extended.project.findFirst({
      where: {
        id: projectId,
        team: {
          members: {
            some: { userId },
          },
        },
      },
    });

    if (!project) {
      throw new ForbiddenException('Project access denied');
    }

    return this.prisma.extended.task.findMany({
      where: { projectId },
      include: {
        assignee: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
        attachments: {
          select: {
            id: true,
            filename: true,
            url: true,
            mimetype: true,
            size: true,
            createdAt: true,
          },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  /**
   * English: Recovery method for soft-deleted tasks.
   * This is useful for compliance and user-requested recovery.
   * Only accessible to admins or team owners.
   */
  async restoreTask(taskId: number) {
    return (this.prisma.extended.task as any).restore(taskId);
  }

  /**
   * English: Permanent deletion of a task.
   * This operation cannot be undone. Use with extreme caution.
   * Should only be called after user confirmation and audit logging.
   */
  async permanentlyDeleteTask(taskId: number) {
    // English: First, hard-delete all attachments
    const attachments = await this.prisma.attachment.findMany({
      where: { taskId },
    });

    // English: Delete attachments from storage
    for (const attachment of attachments) {
      try {
        await this.storageService.deleteFile(attachment.url);
      } catch (error) {
        this.logger.warn(
          `Failed to delete attachment file ${attachment.id} from storage`,
        );
      }
    }

    // English: Hard delete the task (bypasses soft-delete logic)
    return this.prisma.task.delete({
      where: { id: taskId },
    });
  }
}


================================================================================
File: bff-nestjs/src/modules/teams/dto/create-team.dto.ts
Size: 448 B
================================================================================

import { IsNotEmpty, IsString, MinLength, MaxLength } from 'class-validator';
import { ApiProperty } from '@nestjs/swagger';

export class CreateTeamDto {
  @ApiProperty({
    description: 'The name of the team',
    example: 'Engineering Team',
  })
  @IsString()
  @IsNotEmpty()
  @MinLength(3, { message: 'Team name must be at least 3 characters long' })
  @MaxLength(50, { message: 'Team name cannot exceed 50 characters' })
  name!: string;
}


================================================================================
File: bff-nestjs/src/modules/teams/dto/invite-member.dto.ts
Size: 403 B
================================================================================

import { IsEmail, IsNotEmpty } from 'class-validator';
import { Transform } from 'class-transformer';
import { ApiProperty } from '@nestjs/swagger';

export class InviteMemberDto {
  @ApiProperty({
    description: 'Email address of the user to invite',
    example: 'colleague@example.com',
  })
  @IsEmail()
  @IsNotEmpty()
  @Transform(({ value }) => value?.trim().toLowerCase())
  email!: string;
}


================================================================================
File: bff-nestjs/src/modules/teams/teams.controller.spec.ts
Size: 2.79 kB
================================================================================

// bff-nestjs/src/modules/teams/teams.controller.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { TeamsController } from './teams.controller';
import { TeamsService } from './teams.service';
import { PrismaService } from '@/prisma/prisma.service'; // English: Fixed with Alias
import { Reflector } from '@nestjs/core';
import { AtGuard } from '@/auth/guards/at.guard'; // English: Fixed with Alias
import { RolesGuard } from '@/common/guards/roles.guard'; // English: Fixed with Alias
import { TeamOwnerGuard } from '@/common/guards/team-owner.guard'; // English: Fixed with Alias
import { CreateTeamDto } from './dto/create-team.dto';

describe('TeamsController', () => {
  let controller: TeamsController;
  let service: TeamsService;

  // English: Mocking the service methods used in the controller
  const mockTeamsService = {
    create: jest.fn(),
    findAll: jest.fn(),
    remove: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [TeamsController],
      providers: [
        { provide: TeamsService, useValue: mockTeamsService },
        { provide: PrismaService, useValue: {} }, // English: Mocked Prisma dependency
        Reflector,
      ],
    })
      // English: Bypassing guards for unit testing the controller logic
      .overrideGuard(AtGuard)
      .useValue({ canActivate: () => true })
      .overrideGuard(RolesGuard)
      .useValue({ canActivate: () => true })
      .overrideGuard(TeamOwnerGuard)
      .useValue({ canActivate: () => true })
      .compile();

    controller = module.get<TeamsController>(TeamsController);
    service = module.get<TeamsService>(TeamsService);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('create', () => {
    it('should call create team service', async () => {
      const userId = 1;
      const dto: CreateTeamDto = { name: 'New Team' };
      mockTeamsService.create.mockResolvedValue({ id: 1, ...dto });

      await controller.create(userId, dto);
      expect(service.create).toHaveBeenCalledWith(userId, dto);
    });
  });

  describe('findAll', () => {
    it('should call findAll team service', async () => {
      const userId = 1;
      mockTeamsService.findAll.mockResolvedValue([]);

      await controller.findAll(userId);
      expect(service.findAll).toHaveBeenCalledWith(userId);
    });
  });

  describe('remove', () => {
    it('should call remove service with correct ID', async () => {
      const id = 10;
      mockTeamsService.remove.mockResolvedValue({ id, deletedAt: new Date() });

      const result = await controller.remove(id);

      expect(service.remove).toHaveBeenCalledWith(id);
      expect(result.id).toBe(id);
    });
  });
});


================================================================================
File: bff-nestjs/src/modules/teams/teams.controller.ts
Size: 1.63 kB
================================================================================

// bff-nestjs/src/modules/teams/teams.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  UseGuards,
  Delete,
  Param,
  ParseIntPipe,
} from '@nestjs/common';
import { ApiTags, ApiOperation, ApiBearerAuth } from '@nestjs/swagger';
import { TeamsService } from './teams.service';
import { CreateTeamDto } from './dto/create-team.dto';

// English: Using Path Aliases (@/) to fix TS2307 and ensure clean imports
import { GetCurrentUserId } from '@/common/decorators/get-current-user-id.decorator';
import { RolesGuard } from '@/common/guards/roles.guard';
import { TeamOwnerGuard } from '@/common/guards/team-owner.guard';
import { Roles } from '@/common/decorators/roles.decorator';
import { Role } from '@prisma/client';
import { AtGuard } from '@/auth/guards/at.guard';

@ApiTags('Teams')
@ApiBearerAuth('access-token')
@Controller('teams')
@UseGuards(AtGuard, RolesGuard)
export class TeamsController {
  constructor(private readonly teamsService: TeamsService) {}

  @Post()
  @Roles(Role.USER, Role.ADMIN)
  @ApiOperation({ summary: 'Create a new team' })
  create(@GetCurrentUserId() userId: number, @Body() dto: CreateTeamDto) {
    return this.teamsService.create(userId, dto);
  }

  @Get()
  @ApiOperation({ summary: 'List user teams' })
  findAll(@GetCurrentUserId() userId: number) {
    return this.teamsService.findAll(userId);
  }

  @Delete(':id')
  @UseGuards(TeamOwnerGuard) // English: Specific resource authorization for SaaS owners
  @ApiOperation({ summary: 'Soft-delete a team (Owner only)' })
  remove(@Param('id', ParseIntPipe) id: number) {
    return this.teamsService.remove(id);
  }
}


================================================================================
File: bff-nestjs/src/modules/teams/teams.module.ts
Size: 457 B
================================================================================

import { Module } from '@nestjs/common';
import { TeamsService } from './teams.service';
import { TeamsController } from './teams.controller';
import { AuthModule } from '../../auth/auth.module';
import { PrismaModule } from '../../prisma/prisma.module'; // English: Added PrismaModule

@Module({
  imports: [AuthModule, PrismaModule],
  controllers: [TeamsController],
  providers: [TeamsService],
  exports: [TeamsService],
})
export class TeamsModule {}


================================================================================
File: bff-nestjs/src/modules/teams/teams.service.spec.ts
Size: 2.29 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { TeamsService } from './teams.service';
import { PrismaService } from '../../prisma/prisma.service';
import { TeamRole } from '@prisma/client';

describe('TeamsService', () => {
  let service: TeamsService;
  let prisma: PrismaService;

  const mockUserId = 1;
  const mockTeamDto = { name: 'Engineering Team' };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TeamsService,
        {
          provide: PrismaService,
          useValue: {
            extended: {
              $transaction: jest.fn(),
              team: {
                findMany: jest.fn(),
              },
            },
          },
        },
      ],
    }).compile();

    service = module.get<TeamsService>(TeamsService);
    prisma = module.get<PrismaService>(PrismaService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create', () => {
    it('should create a team and its owner within a transaction', async () => {
      const mockTeam = { id: 10, name: mockTeamDto.name };

      // English: Mocking the transaction flow
      (prisma.extended.$transaction as jest.Mock).mockImplementation(
        async (callback) => {
          const tx = {
            team: { create: jest.fn().mockResolvedValue(mockTeam) },
            teamMember: { create: jest.fn().mockResolvedValue({}) },
          };
          return callback(tx);
        },
      );

      const result = await service.create(mockUserId, mockTeamDto);

      expect(result).toEqual(mockTeam);
      expect(prisma.extended.$transaction).toHaveBeenCalled();
    });
  });

  describe('findAll', () => {
    it('should return teams where the user is a member', async () => {
      const mockTeams = [
        { id: 1, name: 'Team A' },
        { id: 2, name: 'Team B' },
      ];
      (prisma.extended.team.findMany as jest.Mock).mockResolvedValue(mockTeams);

      const result = await service.findAll(mockUserId);

      expect(result).toHaveLength(2);
      expect(prisma.extended.team.findMany).toHaveBeenCalledWith(
        expect.objectContaining({
          where: { members: { some: { userId: mockUserId } } },
        }),
      );
    });
  });
});


================================================================================
File: bff-nestjs/src/modules/teams/teams.service.ts
Size: 2.11 kB
================================================================================

// bff-nestjs/src/teams/teams.service.ts
import { Injectable, Logger, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CreateTeamDto } from './dto/create-team.dto';
import { TeamRole } from '@prisma/client';

@Injectable()
export class TeamsService {
  private readonly logger = new Logger(TeamsService.name);

  constructor(private prisma: PrismaService) {}

  async create(userId: number, dto: CreateTeamDto) {
    return this.prisma.extended.$transaction(async (tx) => {
      const team = await tx.team.create({
        data: { name: dto.name },
      });

      await tx.teamMember.create({
        data: {
          userId: userId,
          teamId: team.id,
          role: TeamRole.OWNER,
        },
      });

      this.logger.log(
        `Team created: ${team.name} (ID: ${team.id}) by User: ${userId}`,
      );
      return team;
    });
  }

  async findAll(userId: number) {
    return this.prisma.extended.team.findMany({
      where: {
        members: { some: { userId } },
      },
      include: {
        _count: { select: { members: true, projects: true } },
      },
    });
  }

  /**
   * Enterprise SaaS Logic: Soft delete team and all associated resources.
   * Only called after TeamOwnerGuard validation.
   */
  async remove(teamId: number) {
    return this.prisma.extended.$transaction(async (tx) => {
      const now = new Date();

      // 1. English: Cascade soft-delete for tasks
      await (tx as any).task.updateMany({
        where: { project: { teamId } },
        data: { deletedAt: now },
      });

      // 2. English: Cascade soft-delete for projects
      await (tx as any).project.updateMany({
        where: { teamId },
        data: { deletedAt: now },
      });

      // 3. English: Soft-delete the team
      const team = await (tx as any).team.update({
        where: { id: teamId },
        data: { deletedAt: now },
      });

      this.logger.warn(
        `SaaS Tenant Deactivated: Team ${teamId} and cascading resources marked as deleted.`,
      );
      return team;
    });
  }
}


================================================================================
File: bff-nestjs/src/prisma/prisma.module.ts
Size: 210 B
================================================================================

import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Global()
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}


================================================================================
File: bff-nestjs/src/prisma/prisma.service.ts
Size: 3.9 kB
================================================================================

import {
  Injectable,
  OnModuleInit,
  OnModuleDestroy,
  Logger,
} from '@nestjs/common';
// English: Import both PrismaClient and the Prisma namespace for extensions
import { PrismaClient, Prisma } from '@prisma/client';

@Injectable()
export class PrismaService
  extends PrismaClient
  implements OnModuleInit, OnModuleDestroy
{
  private readonly logger = new Logger(PrismaService.name);

  /**
   * Enterprise Standard: Prisma Client Extension for Soft Delete.
   * This logic ensures that deleted records are hidden by default and
   * provides a professional way to handle data.
   *
   * The extension uses query middleware to automatically filter deleted records
   * in read operations, and model extensions to provide utility methods.
   */
  readonly extended = this.$extends({
    query: {
      $allModels: {
        async findMany({ args, query }) {
          // English: Automatic filter for soft-deleted records
          // If where clause doesn't exist, create it
          args.where = {
            ...(args.where || {}),
            deletedAt: null,
          };
          return query(args);
        },

        async findFirst({ args, query }) {
          // English: Same soft-delete filter as findMany
          args.where = {
            ...(args.where || {}),
            deletedAt: null,
          };
          return query(args);
        },

        async findUnique({ args, query }) {
          // English: Redirect findUnique to findFirst to support deletedAt filter.
          // This ensures that even unique lookups respect the soft-delete policy.
          args.where = {
            ...(args.where || {}),
            deletedAt: null,
          };
          // Cast to any because Prisma's type system doesn't fully support this pattern
          return (query as any)(args);
        },

        async count({ args, query }) {
          // English: Include soft-delete filter in count queries
          args.where = {
            ...(args.where || {}),
            deletedAt: null,
          };
          return query(args);
        },
      },
    },

    model: {
      $allModels: {
        /**
         * Custom method for soft deletion.
         * Usage: await this.prisma.extended.task.softDelete(id)
         * This is a convenience method that performs a soft delete operation.
         */
        async softDelete<T, A>(this: T, id: number) {
          const context = Prisma.getExtensionContext(this);
          return (context as any).update({
            where: { id },
            data: { deletedAt: new Date() },
          });
        },

        /**
         * Custom method for restoring soft-deleted records.
         * Usage: await this.prisma.extended.task.restore(id)
         * This is useful for recovery scenarios in enterprise applications.
         */
        async restore<T, A>(this: T, id: number) {
          const context = Prisma.getExtensionContext(this);
          return (context as any).update({
            where: { id },
            data: { deletedAt: null },
          });
        },

        /**
         * Custom method to count only deleted records.
         * Usage: await this.prisma.extended.task.countDeleted()
         * Useful for audit and compliance reporting.
         */
        async countDeleted<T, A>(this: T) {
          const context = Prisma.getExtensionContext(this);
          return (context as any).count({
            where: { deletedAt: { not: null } },
          });
        },
      },
    },
  });

  async onModuleInit() {
    try {
      await this.$connect();
      this.logger.log('Database connection established successfully');
    } catch (error) {
      this.logger.error('Database connection failed', error);
      // English: Critical failure, stop the process if DB is unreachable
      process.exit(1);
    }
  }

  async onModuleDestroy() {
    await this.$disconnect();
  }
}


================================================================================
File: bff-nestjs/src/prisma/prisma.types.ts
Size: 2.47 kB
================================================================================

/**
 * Prisma Type Utilities and Configurations
 * English: This file provides type-safe utilities for working with Prisma extensions
 * and soft-delete operations in a production SaaS environment.
 */

import { Prisma } from '@prisma/client';

/**
 * Represents models that support soft delete functionality.
 * Update this union type when adding deletedAt field to new models.
 */
export type SoftDeleteModel =
  | 'user'
  | 'team'
  | 'project'
  | 'task'
  | 'attachment';

/**
 * Type for Prisma where clauses that include soft-delete filtering.
 * This ensures type safety when building where clauses manually.
 */
export interface SoftDeleteWhereInput {
  deletedAt?: {
    equals?: null;
    not?: null;
    isSet?: boolean;
  };
}

/**
 * Options for soft-delete operations.
 * Useful for controlling behavior in different contexts.
 */
export interface SoftDeleteOptions {
  /**
   * If true, permanently deletes the record instead of soft-deleting.
   * Use with caution in production!
   */
  hardDelete?: boolean;

  /**
   * If true, includes soft-deleted records in the response.
   * Useful for admin/audit operations.
   */
  includeSoftDeleted?: boolean;
}

/**
 * English: Helper function to build a where clause that excludes soft-deleted records.
 * Usage: const activeUsers = await prisma.user.findMany({
 *   where: withoutDeleted({ role: 'ADMIN' })
 * })
 */
export function withoutDeleted<T extends Record<string, any>>(
  where?: T,
): T & { deletedAt: null } {
  return {
    ...(where || {}),
    deletedAt: null,
  } as T & { deletedAt: null };
}

/**
 * English: Helper function to build a where clause that includes only soft-deleted records.
 * Useful for recovery and audit operations.
 * Usage: const deletedTasks = await prisma.task.findMany({
 *   where: onlyDeleted({ projectId: 1 })
 * })
 */
export function onlyDeleted<T extends Record<string, any>>(
  where?: T,
): T & { deletedAt: { not: null } } {
  return {
    ...(where || {}),
    deletedAt: { not: null },
  } as T & { deletedAt: { not: null } };
}

/**
 * English: Type-safe wrapper for update operations with soft-delete support.
 * This prevents accidental direct updates to the deletedAt field.
 */
export function softDeleteData(data: any, options?: SoftDeleteOptions): any {
  // English: Prevent accidental overwrites of deletedAt in normal operations
  if (!options?.hardDelete && data.deletedAt !== undefined) {
    delete data.deletedAt;
  }
  return data;
}


================================================================================
File: bff-nestjs/src/storage/storage.module.ts
Size: 364 B
================================================================================

// src/storage/storage.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { StorageService } from './storage.service';

@Module({
  imports: [ConfigModule],
  providers: [StorageService],
  exports: [StorageService], // English: Exporting to make it available in other modules
})
export class StorageModule {}


================================================================================
File: bff-nestjs/src/storage/storage.service.spec.ts
Size: 2.72 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { StorageService } from './storage.service';
import { ConfigService } from '@nestjs/config';
import { S3Client } from '@aws-sdk/client-s3';

// Mock AWS SDK
jest.mock('@aws-sdk/client-s3', () => {
  return {
    S3Client: jest.fn().mockImplementation(() => ({
      send: jest.fn().mockResolvedValue({}),
    })),
    PutObjectCommand: jest.fn(),
    DeleteObjectCommand: jest.fn(),
  };
});

describe('StorageService', () => {
  let service: StorageService;
  let config: ConfigService;
  let s3ClientInstance: any;

  const mockConfig = {
    get: jest.fn((key: string) => {
      const configMap = {
        STORAGE_REGION: 'us-east-1',
        STORAGE_ENDPOINT: 'http://localhost:9000',
        STORAGE_ACCESS_KEY: 'key',
        STORAGE_SECRET_KEY: 'secret',
        STORAGE_BUCKET: 'my-bucket',
      };
      return configMap[key];
    }),
  };

  beforeEach(async () => {
    jest.clearAllMocks();
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        StorageService,
        { provide: ConfigService, useValue: mockConfig },
      ],
    }).compile();

    service = module.get<StorageService>(StorageService);
    config = module.get<ConfigService>(ConfigService);

    // Retrieve the mocked instance created during service instantiation
    s3ClientInstance = (S3Client as jest.Mock).mock.results[0].value;
  });

  it('should upload a file and return the URL', async () => {
    const mockFile = {
      originalname: 'test.png',
      buffer: Buffer.from('test'),
      mimetype: 'image/png',
    } as any;

    const url = await service.uploadFile(mockFile);

    expect(url).toContain('http://localhost:9000/my-bucket/task-attachments/');
    expect(url).toContain('test.png');
  });

  it('should delete a file successfully', async () => {
    const fileUrl =
      'http://localhost:9000/my-bucket/task-attachments/123-test.png';
    await expect(service.deleteFile(fileUrl)).resolves.not.toThrow();
  });

  it('should throw error if bucket marker is not found in URL', async () => {
    const invalidUrl = 'http://localhost:9000/wrong-marker/file.png';
    await expect(service.deleteFile(invalidUrl)).rejects.toThrow(
      'Bucket marker /my-bucket/ not found in URL',
    );
  });

  it('should log and rethrow error if S3 delete fails', async () => {
    // Force the send method to reject for this specific test
    jest
      .spyOn(s3ClientInstance, 'send')
      .mockRejectedValueOnce(new Error('S3 Failure'));

    const fileUrl =
      'http://localhost:9000/my-bucket/task-attachments/123-test.png';

    await expect(service.deleteFile(fileUrl)).rejects.toThrow('S3 Failure');
  });
});


================================================================================
File: bff-nestjs/src/storage/storage.service.ts
Size: 2.78 kB
================================================================================

import { Injectable, Logger } from '@nestjs/common';
import {
  S3Client,
  PutObjectCommand,
  DeleteObjectCommand,
} from '@aws-sdk/client-s3';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class StorageService {
  private s3Client: S3Client;
  private readonly logger = new Logger(StorageService.name);

  constructor(private config: ConfigService) {
    // Initialize S3 Client with credentials from environment
    this.s3Client = new S3Client({
      region: this.config.get<string>('STORAGE_REGION')!,
      endpoint: this.config.get<string>('STORAGE_ENDPOINT')!,
      credentials: {
        accessKeyId: this.config.get<string>('STORAGE_ACCESS_KEY')!,
        secretAccessKey: this.config.get<string>('STORAGE_SECRET_KEY')!,
      },
      forcePathStyle: true,
    });
  }

  async uploadFile(file: Express.Multer.File): Promise<string> {
    const bucket = this.config.get<string>('STORAGE_BUCKET')!;
    const fileKey = `task-attachments/${Date.now()}-${file.originalname}`;

    const command = new PutObjectCommand({
      Bucket: bucket,
      Key: fileKey,
      Body: file.buffer,
      ContentType: file.mimetype,
    });

    await this.s3Client.send(command);

    const endpoint = this.config.get<string>('STORAGE_ENDPOINT')!;
    return `${endpoint}/${bucket}/${fileKey}`;
  }

  /**
   * Deletes a file from Cloud Storage bucket with key extraction
   * English: Extracts the file key from the full URL and deletes it from S3
   * Works with Supabase S3 endpoint format
   */
  async deleteFile(fileUrl: string): Promise<void> {
    const bucket = this.config.get<string>('STORAGE_BUCKET')!;

    try {
      // English: Extract the file key from the URL
      // URL format: https://iaqnnevdkhpkpyrwecfh.storage.supabase.co/storage/v1/s3/{bucket}/task-attachments/...
      // We need to extract: task-attachments/FILENAME

      const bucketMarker = `/${bucket}/`;
      const markerIndex = fileUrl.indexOf(bucketMarker);

      if (markerIndex === -1) {
        throw new Error(
          `Bucket marker "${bucketMarker}" not found in URL: ${fileUrl}`,
        );
      }

      // English: Extract everything after the bucket name (the file key)
      const fileKey = fileUrl.substring(markerIndex + bucketMarker.length);

      this.logger.log(`Attempting to delete cloud file with key: ${fileKey}`);

      const command = new DeleteObjectCommand({
        Bucket: bucket,
        Key: fileKey,
      });

      await this.s3Client.send(command);

      this.logger.log(`Successfully deleted file: ${fileKey}`);
    } catch (error: unknown) {
      const errorMessage =
        error instanceof Error ? error.message : 'Unknown error';
      this.logger.error(`Cloud Delete Error: ${errorMessage}`);
      throw error;
    }
  }
}


================================================================================
File: bff-nestjs/test/auth.e2e-spec.ts
Size: 2.97 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import request from 'supertest';
import cookieParser from 'cookie-parser';
import { AppModule } from './../src/app.module';
import { PrismaService } from './../src/prisma/prisma.service';

describe('AuthController (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;

  const testUser = {
    email: `e2e-auth-${Date.now()}@productivity.com`,
    password: 'password123',
    name: 'Nikolas Tesla',
  };

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();

    app.useGlobalPipes(
      new ValidationPipe({
        whitelist: true,
        transform: true,
        forbidNonWhitelisted: true,
      }),
    );
    app.use(cookieParser());

    await app.init();
    prisma = app.get<PrismaService>(PrismaService);
  });

  afterAll(async () => {
    await prisma.user.deleteMany({
      where: { email: testUser.email },
    });
    await prisma.$disconnect();
    await app.close();
  });

  describe('Authentication Flow', () => {
    it('/auth/signup (POST) - Success with RegisterDto', async () => {
      const response = await request(app.getHttpServer())
        .post('/auth/signup')
        .send({
          email: testUser.email,
          password: testUser.password,
          name: testUser.name,
        })
        .expect(201);

      expect(response.body).toHaveProperty('access_token');

      // English: Safe way to check cookies without TS errors
      const cookies = response.get('Set-Cookie');
      expect(cookies).toBeDefined();
      if (cookies) {
        expect(cookies[0]).toContain('refresh_token');
      }
    });

    it('/auth/signin (POST) - Success with LoginDto', async () => {
      const response = await request(app.getHttpServer())
        .post('/auth/signin')
        .send({
          email: testUser.email,
          password: testUser.password,
        })
        .expect(200);

      expect(response.body).toHaveProperty('access_token');
      expect(response.get('Set-Cookie')).toBeDefined();
    });

    it('/auth/logout (POST) - Success', async () => {
      const loginRes = await request(app.getHttpServer())
        .post('/auth/signin')
        .send({
          email: testUser.email,
          password: testUser.password,
        });

      const at = loginRes.body.access_token;

      return request(app.getHttpServer())
        .post('/auth/logout')
        .set('Authorization', `Bearer ${at}`)
        .expect(200);
    });

    it('/auth/signup (POST) - Should fail if name is missing', async () => {
      return request(app.getHttpServer())
        .post('/auth/signup')
        .send({
          email: 'noname@test.com',
          password: 'password123',
        })
        .expect(400);
    });
  });
});


================================================================================
File: bff-nestjs/test/invitations.e2e-spec.ts
Size: 3.63 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import request from 'supertest';
import { AppModule } from './../src/app.module';
import { PrismaService } from './../src/prisma/prisma.service';

describe('Invitations (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let ownerToken: string;
  let guestToken: string;
  let teamId: number;
  let invitationToken: string;

  const ownerUser = {
    email: 'owner@test.com',
    password: 'password123',
    name: 'Owner',
  };

  const guestUser = {
    email: 'guest@test.com',
    password: 'password123',
    name: 'Guest',
  };

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(new ValidationPipe());
    await app.init();

    prisma = app.get<PrismaService>(PrismaService);

    // 1. Create Owner and Team
    await request(app.getHttpServer()).post('/auth/signup').send(ownerUser);

    const loginOwner = await request(app.getHttpServer())
      .post('/auth/signin')
      .send(ownerUser);

    ownerToken = loginOwner.body.access_token;

    const teamRes = await request(app.getHttpServer())
      .post('/teams')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ name: 'E2E Team' });

    teamId = teamRes.body.id;

    // Verify owner was created with OWNER role
    const ownerMember = await prisma.teamMember.findFirst({
      where: {
        teamId,
        user: { email: ownerUser.email },
      },
    });
    console.log('Owner member after team creation:', ownerMember);

    // 2. Create Guest User
    await request(app.getHttpServer()).post('/auth/signup').send(guestUser);

    const loginGuest = await request(app.getHttpServer())
      .post('/auth/signin')
      .send(guestUser);

    guestToken = loginGuest.body.access_token;
  });

  afterAll(async () => {
    await prisma.user.deleteMany({
      where: { email: { in: [ownerUser.email, guestUser.email] } },
    });
    await prisma.team.deleteMany({ where: { name: 'E2E Team' } });
    await prisma.$disconnect();
    await app.close();
  });

  it('POST /invitations/team/:id/send - Should send invitation', async () => {
    const res = await request(app.getHttpServer())
      .post(`/invitations/team/${teamId}/send`)
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ email: guestUser.email, role: 'MEMBER' })
      .expect(201);

    expect(res.body.message).toBeDefined();
    expect(res.body.invitationId).toBeDefined();

    const inv = await prisma.invitation.findFirst({
      where: { email: guestUser.email },
    });

    invitationToken = inv!.token;
  });

  it('POST /invitations/accept - Should fail if email mismatch', async () => {
    // Attempting to accept guest's invitation with owner's account
    await request(app.getHttpServer())
      .post('/invitations/accept')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ token: invitationToken })
      .expect(403);
  });

  it('POST /invitations/accept - Should join team successfully', async () => {
    await request(app.getHttpServer())
      .post('/invitations/accept')
      .set('Authorization', `Bearer ${guestToken}`)
      .send({ token: invitationToken })
      .expect(201);

    // Verify membership
    const member = await prisma.teamMember.findFirst({
      where: {
        teamId,
        user: { email: guestUser.email },
      },
    });

    expect(member).toBeDefined();
  });
});


================================================================================
File: bff-nestjs/test/jest-e2e.json
Size: 183 B
================================================================================

{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}


================================================================================
File: bff-nestjs/test/tasks.e2e-spec.ts
Size: 3.77 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import request from 'supertest';
import cookieParser from 'cookie-parser';
import { AppModule } from './../src/app.module';
import { PrismaService } from './../src/prisma/prisma.service';

describe('Tasks (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let accessToken: string;
  let userId: number;
  let projectId: number;

  const testUser = {
    email: `tasks-e2e-${Date.now()}@test.com`,
    password: 'password123',
    name: 'Task Tester',
  };

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(
      new ValidationPipe({ whitelist: true, transform: true }),
    );
    app.use(cookieParser());
    await app.init();
    prisma = app.get<PrismaService>(PrismaService);

    // --- SETUP: Create User, Team and Project ---
    // 1. Signup & Signin
    await request(app.getHttpServer()).post('/auth/signup').send(testUser);
    const loginRes = await request(app.getHttpServer())
      .post('/auth/signin')
      .send({
        email: testUser.email,
        password: testUser.password,
      });
    accessToken = loginRes.body.access_token;

    const user = await prisma.user.findUnique({
      where: { email: testUser.email },
    });
    userId = user!.id;

    // 2. Create Team
    const team = await prisma.team.create({
      data: {
        name: 'E2E Team',
        members: { create: { userId, role: 'OWNER' } },
      },
    });

    // 3. Create Project
    const project = await prisma.project.create({
      data: {
        name: 'E2E Project',
        teamId: team.id,
      },
    });
    projectId = project.id;
  });

  afterAll(async () => {
    // English: Cleanup database
    await prisma.user.deleteMany({ where: { email: testUser.email } });
    await prisma.team.deleteMany({ where: { name: 'E2E Team' } });
    await prisma.$disconnect();
    await app.close();
  });

  describe('/tasks', () => {
    it('POST /tasks - Should create a task', async () => {
      const createTaskDto = {
        title: 'Finish E2E Tests',
        description: 'Testing the task creation flow',
        projectId: projectId,
        status: 'TODO',
      };

      const response = await request(app.getHttpServer())
        .post('/tasks')
        .set('Authorization', `Bearer ${accessToken}`)
        .send(createTaskDto)
        .expect(201);

      expect(response.body).toHaveProperty('id');
      expect(response.body.title).toBe(createTaskDto.title);
    });

    it('GET /tasks/project/:id - Should return tasks for the project', async () => {
      const response = await request(app.getHttpServer())
        .get(`/tasks/project/${projectId}`)
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(200);

      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBeGreaterThan(0);
    });

    it('POST /tasks - Should fail if user is not in the team', async () => {
      // English: Create a project in a team where the user is NOT a member
      const otherTeam = await prisma.team.create({
        data: { name: 'Other Team' },
      });
      const otherProject = await prisma.project.create({
        data: { name: 'Unauthorized Project', teamId: otherTeam.id },
      });

      return request(app.getHttpServer())
        .post('/tasks')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          title: 'Hacker Task',
          projectId: otherProject.id,
        })
        .expect(403); // English: Forbidden
    });
  });
});


================================================================================
File: bff-nestjs/test/teams.e2e-spec.ts
Size: 2.48 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import request from 'supertest';
import { AppModule } from './../src/app.module';
import { PrismaService } from './../src/prisma/prisma.service';

describe('Teams (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let accessToken: string;
  let userId: number;

  const testUser = {
    email: `team-e2e-${Date.now()}@test.com`,
    password: 'password123',
    name: 'Team Manager',
  };

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(new ValidationPipe());
    await app.init();
    prisma = app.get<PrismaService>(PrismaService);

    // Setup: User & Auth
    await request(app.getHttpServer()).post('/auth/signup').send(testUser);
    const loginRes = await request(app.getHttpServer())
      .post('/auth/signin')
      .send({
        email: testUser.email,
        password: testUser.password,
      });
    accessToken = loginRes.body.access_token;

    const user = await prisma.user.findUnique({
      where: { email: testUser.email },
    });
    userId = user!.id;
  });

  afterAll(async () => {
    await prisma.user.deleteMany({ where: { email: testUser.email } });
    await prisma.$disconnect();
    await app.close();
  });

  describe('/teams', () => {
    it('POST /teams - Should create a team and assign user as OWNER', async () => {
      const response = await request(app.getHttpServer())
        .post('/teams')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({ name: 'Alpha Team' })
        .expect(201);

      expect(response.body.name).toBe('Alpha Team');

      // English: Verify in DB that the membership was created correctly
      const membership = await prisma.teamMember.findFirst({
        where: { teamId: response.body.id, userId: userId },
      });
      expect(membership?.role).toBe('OWNER');
    });

    it('GET /teams - Should list user teams', async () => {
      const response = await request(app.getHttpServer())
        .get('/teams')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(200);

      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.some((t: any) => t.name === 'Alpha Team')).toBe(
        true,
      );
    });
  });
});


================================================================================
File: bff-nestjs/tsconfig.build.json
Size: 97 B
================================================================================

{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}


================================================================================
File: bff-nestjs/tsconfig.json
Size: 528 B
================================================================================

{
  "compilerOptions": {
    "module": "CommonJS",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2022",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strict": true,
    "noImplicitAny": false,
    "esModuleInterop": true,
    "types": ["node", "jest", "multer"],
    "paths": {
      "@/*": ["src/*"]
    }
  }
}


================================================================================
File: docker-compose.yml
Size: 943 B
================================================================================

version: '3.8'

services:
  tpp-db:
    image: postgres:15-alpine
    container_name: tpp-db
    restart: always
    environment:
      # English: Matches your DATABASE_URL in .env
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: productivity_db
    ports:
      - '5432:5432'
    networks:
      - tpp-network
    volumes:
      - tpp-db-data:/var/lib/postgresql/data

  tpp-redis:
    image: redis:7-alpine
    container_name: tpp-redis
    restart: always
    ports:
      - '6379:6379'
    healthcheck:
      test: ['CMD', 'redis-cli', 'ping']
      interval: 5s
      timeout: 3s
      retries: 5
    networks:
      - tpp-network

  tpp-maildev:
    image: maildev/maildev
    container_name: tpp-maildev
    restart: always
    ports:
      - '1080:1080' # Web UI
      - '1025:1025' # SMTP Server
    networks:
      - tpp-network

networks:
  tpp-network:
    driver: bridge

volumes:
  tpp-db-data:


================================================================================
File: eslint.config.mjs
Size: 899 B
================================================================================

// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      sourceType: 'commonjs',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'warn',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      "prettier/prettier": ["error", { endOfLine: "auto" }],
    },
  },
);


================================================================================
File: frontend-next/README.md
Size: 1.45 kB
================================================================================

This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.


================================================================================
File: frontend-next/components/ui/avatar.tsx
Size: 2.91 kB
================================================================================

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  size = "default",
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root> & {
  size?: "default" | "sm" | "lg"
}) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      data-size={size}
      className={cn(
        "group/avatar relative flex size-8 shrink-0 overflow-hidden rounded-full select-none data-[size=lg]:size-10 data-[size=sm]:size-6",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted text-muted-foreground flex size-full items-center justify-center rounded-full text-sm group-data-[size=sm]/avatar:text-xs",
        className
      )}
      {...props}
    />
  )
}

function AvatarBadge({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="avatar-badge"
      className={cn(
        "bg-primary text-primary-foreground ring-background absolute right-0 bottom-0 z-10 inline-flex items-center justify-center rounded-full ring-2 select-none",
        "group-data-[size=sm]/avatar:size-2 group-data-[size=sm]/avatar:[&>svg]:hidden",
        "group-data-[size=default]/avatar:size-2.5 group-data-[size=default]/avatar:[&>svg]:size-2",
        "group-data-[size=lg]/avatar:size-3 group-data-[size=lg]/avatar:[&>svg]:size-2",
        className
      )}
      {...props}
    />
  )
}

function AvatarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="avatar-group"
      className={cn(
        "*:data-[slot=avatar]:ring-background group/avatar-group flex -space-x-2 *:data-[slot=avatar]:ring-2",
        className
      )}
      {...props}
    />
  )
}

function AvatarGroupCount({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="avatar-group-count"
      className={cn(
        "bg-muted text-muted-foreground ring-background relative flex size-8 shrink-0 items-center justify-center rounded-full text-sm ring-2 group-has-data-[size=lg]/avatar-group:size-10 group-has-data-[size=sm]/avatar-group:size-6 [&>svg]:size-4 group-has-data-[size=lg]/avatar-group:[&>svg]:size-5 group-has-data-[size=sm]/avatar-group:[&>svg]:size-3",
        className
      )}
      {...props}
    />
  )
}

export {
  Avatar,
  AvatarImage,
  AvatarFallback,
  AvatarBadge,
  AvatarGroup,
  AvatarGroupCount,
}


================================================================================
File: frontend-next/components/ui/button.tsx
Size: 2.4 kB
================================================================================

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        xs: "h-6 gap-1 rounded-md px-2 text-xs has-[>svg]:px-1.5 [&_svg:not([class*='size-'])]:size-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-xs": "size-6 rounded-md [&_svg:not([class*='size-'])]:size-3",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


================================================================================
File: frontend-next/components/ui/card.tsx
Size: 1.99 kB
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-2 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}


================================================================================
File: frontend-next/components/ui/dropdown-menu.tsx
Size: 8.41 kB
================================================================================

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}


================================================================================
File: frontend-next/components/ui/input.tsx
Size: 962 B
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


================================================================================
File: frontend-next/components/ui/label.tsx
Size: 597 B
================================================================================

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }


================================================================================
File: frontend-next/components/ui/separator.tsx
Size: 699 B
================================================================================

"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }


================================================================================
File: frontend-next/components.json
Size: 446 B
================================================================================

{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": false,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "iconLibrary": "lucide",
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "registries": {}
}


================================================================================
File: frontend-next/eslint.config.mjs
Size: 465 B
================================================================================

import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;


================================================================================
File: frontend-next/next.config.ts
Size: 133 B
================================================================================

import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;


================================================================================
File: frontend-next/package.json
Size: 1.13 kB
================================================================================

{
  "name": "frontend-next",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@hookform/resolvers": "^5.2.2",
    "@radix-ui/react-avatar": "^1.1.11",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-separator": "^1.1.8",
    "@radix-ui/react-slot": "^1.2.4",
    "axios": "^1.13.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "js-cookie": "^3.0.5",
    "lucide-react": "^0.563.0",
    "next": "16.1.1",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "react-hook-form": "^7.71.1",
    "sonner": "^2.0.7",
    "tailwind-merge": "^3.4.0",
    "zod": "^4.3.6",
    "zustand": "^5.0.10"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/js-cookie": "^3.0.6",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.1.1",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5"
  }
}


================================================================================
File: frontend-next/postcss.config.mjs
Size: 94 B
================================================================================

const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;


================================================================================
File: frontend-next/public/file.svg
Size: 391 B
================================================================================

<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>

================================================================================
File: frontend-next/public/globe.svg
Size: 1.03 kB
================================================================================

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>

================================================================================
File: frontend-next/public/next.svg
Size: 1.38 kB
================================================================================

<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>

================================================================================
File: frontend-next/public/vercel.svg
Size: 128 B
================================================================================

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>

================================================================================
File: frontend-next/public/window.svg
Size: 385 B
================================================================================

<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>

================================================================================
File: frontend-next/src/app/auth/login/page.tsx
Size: 3.48 kB
================================================================================

'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { loginSchema, LoginFormData } from '@/core/schemas/auth.schema';
import api from '@/lib/axios';
import { useAuthStore } from '@/store/useAuthStore';
import { toast } from 'sonner';
import Link from 'next/link';

export default function LoginPage() {
  const setAuth = useAuthStore((state) => state.setAuth);

  const {
    register,
    handleSubmit,
    formState: { errors, isSubmitting },
  } = useForm<LoginFormData>({
    resolver: zodResolver(loginSchema),
  });

  const onSubmit = async (data: LoginFormData) => {
    try {
      // English: Standard login request to the NestJS BFF
      const response = await api.post('/auth/signin', data);

      if (response.status === 200 || response.status === 201) {
        const { user, access_token, accessToken } = response.data;
        const token = access_token || accessToken;

        // English: Store data in global state if available
        if (user && token) {
          setAuth(user, token);
        }

        toast.success('Login Successful! Redirecting...');

        // English: Hard redirect to force Next.js Middleware to read the new cookies
        // This solves the "stuck on login" issue you're seeing in Safari
        window.location.assign('/dashboard');
      }
    } catch (err: any) {
      const errorMsg = err.response?.data?.message || 'Invalid credentials';
      toast.error(errorMsg);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-slate-50 p-4">
      <div className="max-w-md w-full p-8 bg-white rounded-xl shadow-lg border border-slate-100 text-slate-900">
        <div className="mb-8 text-center">
          <h2 className="text-2xl font-bold">TeamFlow</h2>
          <p className="text-slate-500 text-sm mt-2">
            Login with admin@test.com
          </p>
        </div>

        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <div>
            <input
              {...register('email')}
              type="email"
              placeholder="Email"
              className="w-full p-2.5 border border-slate-200 rounded-lg outline-none focus:ring-2 focus:ring-blue-500"
            />
            {errors.email && (
              <p className="text-red-500 text-xs mt-1">
                {errors.email.message}
              </p>
            )}
          </div>

          <div>
            <input
              {...register('password')}
              type="password"
              placeholder="Password"
              className="w-full p-2.5 border border-slate-200 rounded-lg outline-none focus:ring-2 focus:ring-blue-500"
            />
            {errors.password && (
              <p className="text-red-500 text-xs mt-1">
                {errors.password.message}
              </p>
            )}
          </div>

          <button
            type="submit"
            disabled={isSubmitting}
            className="w-full py-2.5 bg-blue-600 text-white rounded-lg font-bold hover:bg-blue-700 disabled:opacity-50"
          >
            {isSubmitting ? 'Authenticating...' : 'Sign In'}
          </button>
        </form>

        <p className="mt-6 text-center text-sm">
          Don't have an account?{' '}
          <Link href="/auth/signup" className="text-blue-600 hover:underline">
            Sign up
          </Link>
        </p>
      </div>
    </div>
  );
}


================================================================================
File: frontend-next/src/app/auth/signup/page.tsx
Size: 2.45 kB
================================================================================

'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { signupSchema, SignupFormData } from '@/core/schemas/auth.schema';
import api from '@/lib/axios';
import { useRouter } from 'next/navigation';
import { toast } from 'sonner';
import Link from 'next/link';

export default function SignupPage() {
  const router = useRouter();
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<SignupFormData>({
    resolver: zodResolver(signupSchema),
  });

  const onSubmit = async (data: SignupFormData) => {
    try {
      await api.post('/auth/signup', {
        name: data.name,
        email: data.email,
        password: data.password,
      });
      toast.success('Account created successfully!');
      router.push('/auth/login');
    } catch (err: any) {
      toast.error(err.response?.data?.message || 'Registration failed');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-slate-50 p-4">
      <div className="max-w-md w-full p-8 bg-white rounded-xl shadow-lg border border-slate-100 text-slate-900">
        <h2 className="text-2xl font-bold text-center mb-6">Create Account</h2>
        <form onSubmit={handleSubmit(onSubmit)} className="space-y-4">
          <input
            {...register('name')}
            placeholder="Name"
            className="w-full p-2 border rounded"
          />
          <input
            {...register('email')}
            type="email"
            placeholder="Email"
            className="w-full p-2 border rounded"
          />
          <input
            {...register('password')}
            type="password"
            placeholder="Password"
            className="w-full p-2 border rounded"
          />
          <input
            {...register('confirmPassword')}
            type="password"
            placeholder="Confirm Password"
            className="w-full p-2 border rounded"
          />
          <button
            type="submit"
            className="w-full py-2 bg-blue-600 text-white rounded font-bold hover:bg-blue-700"
          >
            Register
          </button>
        </form>
        <p className="mt-4 text-center text-sm">
          Already have an account?{' '}
          <Link href="/auth/login" className="text-blue-600 hover:underline">
            Log in
          </Link>
        </p>
      </div>
    </div>
  );
}


================================================================================
File: frontend-next/src/app/dashboard/layout.tsx
Size: 1.31 kB
================================================================================

// src/app/(dashboard)/layout.tsx
'use client';

import { Sidebar } from '@/components/layout/Sidebar';
import { UserNav } from '@/components/layout/UserNav';

export default function DashboardLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <div className="flex h-screen bg-slate-50">
      {/* English: Persistent Sidebar for internal navigation */}
      <aside className="w-64 border-r border-slate-200 bg-white flex flex-col">
        <div className="p-6">
          <span className="text-xl font-bold tracking-tight text-slate-900">
            Team<span className="text-blue-600">Flow</span>
          </span>
        </div>

        <div className="flex-1 px-4">
          <Sidebar />
        </div>

        <div className="p-4 border-t border-slate-100">
          <UserNav />
        </div>
      </aside>

      {/* English: Main Content Area where dashboard views are rendered */}
      <main className="flex-1 overflow-y-auto">
        <header className="h-16 border-b border-slate-200 bg-white/50 backdrop-blur-sm flex items-center px-8 sticky top-0 z-10">
          <h1 className="text-sm font-medium text-slate-500">
            Workspace / Dashboard
          </h1>
        </header>
        <div className="p-8">{children}</div>
      </main>
    </div>
  );
}


================================================================================
File: frontend-next/src/app/dashboard/page.tsx
Size: 2.51 kB
================================================================================

'use client';

import { useAuthStore } from '@/store/useAuthStore';
import { LayoutDashboard, CheckCircle2, Clock, Users } from 'lucide-react';

export default function DashboardPage() {
  // English: Accessing user data from global state
  const user = useAuthStore((state) => state.user);

  // English: Mock stats - We will connect these to the backend in the next step
  const stats = [
    {
      label: 'Active Projects',
      value: '1',
      icon: LayoutDashboard,
      color: 'text-blue-600',
    },
    {
      label: 'Tasks Done',
      value: '1',
      icon: CheckCircle2,
      color: 'text-green-600',
    },
    { label: 'In Progress', value: '1', icon: Clock, color: 'text-amber-600' },
    {
      label: 'Team Members',
      value: '1',
      icon: Users,
      color: 'text-purple-600',
    },
  ];

  return (
    <div className="space-y-8 animate-in fade-in duration-500">
      {/* Header Section */}
      <div>
        <h1 className="text-3xl font-bold text-slate-900">
          Welcome back, {user?.name || 'Admin'}!
        </h1>
        <p className="text-slate-500 mt-1">
          Here is what is happening with your projects today.
        </p>
      </div>

      {/* Stats Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {stats.map((stat) => (
          <div
            key={stat.label}
            className="bg-white p-6 rounded-xl border border-slate-200 shadow-sm"
          >
            <div className="flex items-center justify-between">
              <div>
                <p className="text-sm font-medium text-slate-500">
                  {stat.label}
                </p>
                <p className="text-2xl font-bold text-slate-900 mt-1">
                  {stat.value}
                </p>
              </div>
              <stat.icon className={`h-8 w-8 ${stat.color} opacity-80`} />
            </div>
          </div>
        ))}
      </div>

      {/* Role Badge Section */}
      <div className="bg-blue-50 border border-blue-100 p-4 rounded-lg flex items-center justify-between">
        <span className="text-sm text-blue-800 font-medium">
          Logged in as:{' '}
          <span className="font-bold underline">
            {user?.email || 'admin@test.com'}
          </span>
        </span>
        <span className="px-3 py-1 bg-blue-600 text-white rounded-full text-xs font-bold uppercase tracking-wider">
          {user?.role || 'ADMIN'}
        </span>
      </div>
    </div>
  );
}


================================================================================
File: frontend-next/src/app/dashboard/projects/page.tsx
Size: 1.23 kB
================================================================================

// src/app/dashboard/projects/page.tsx
'use client';

import { FolderKanban, Plus } from 'lucide-react';

export default function ProjectsPage() {
  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-slate-900">Projects</h1>
          <p className="text-slate-500 text-sm">
            Manage and track your team's initiatives.
          </p>
        </div>
        <button className="flex items-center gap-2 bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors font-medium">
          <Plus size={18} />
          New Project
        </button>
      </div>

      {/* English: Placeholder for the project list we'll fetch from the backend */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div className="border-2 border-dashed border-slate-200 rounded-xl p-8 flex flex-col items-center justify-center text-slate-400 bg-white">
          <FolderKanban size={48} className="mb-4 opacity-20" />
          <p className="font-medium">No projects found</p>
          <p className="text-xs">Click "New Project" to get started.</p>
        </div>
      </div>
    </div>
  );
}


================================================================================
File: frontend-next/src/app/dashboard/settings/page.tsx
Size: 2.12 kB
================================================================================

// src/app/dashboard/settings/page.tsx
'use client';

import { Settings, Bell, Lock, User } from 'lucide-react';

export default function SettingsPage() {
  return (
    <div className="max-w-4xl mx-auto space-y-6">
      <div>
        <h1 className="text-2xl font-bold text-slate-900">Settings</h1>
        <p className="text-slate-500 text-sm">
          Manage your account preferences and security.
        </p>
      </div>

      <div className="bg-white rounded-xl border border-slate-200 divide-y divide-slate-100 shadow-sm">
        <div className="p-4 flex items-center justify-between hover:bg-slate-50 transition-colors cursor-pointer">
          <div className="flex items-center gap-3">
            <User className="text-slate-400" size={20} />
            <div>
              <p className="text-sm font-medium text-slate-900">
                Profile Information
              </p>
              <p className="text-xs text-slate-500">
                Update your name and email address.
              </p>
            </div>
          </div>
        </div>

        <div className="p-4 flex items-center justify-between hover:bg-slate-50 transition-colors cursor-pointer">
          <div className="flex items-center gap-3">
            <Bell className="text-slate-400" size={20} />
            <div>
              <p className="text-sm font-medium text-slate-900">
                Notifications
              </p>
              <p className="text-xs text-slate-500">
                Configure how you receive alerts.
              </p>
            </div>
          </div>
        </div>

        <div className="p-4 flex items-center justify-between hover:bg-slate-50 transition-colors cursor-pointer text-red-600">
          <div className="flex items-center gap-3">
            <Lock className="text-red-400" size={20} />
            <div>
              <p className="text-sm font-medium">Security</p>
              <p className="text-xs text-red-400">
                Manage your password and sessions.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}


================================================================================
File: frontend-next/src/app/dashboard/teams/page.tsx
Size: 550 B
================================================================================

// src/app/dashboard/teams/page.tsx
'use client';

import { Users } from 'lucide-react';

export default function TeamsPage() {
  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold text-slate-900 flex items-center gap-2">
        <Users className="text-blue-600" />
        My Teams
      </h1>
      <div className="mt-8 bg-white border border-slate-200 rounded-xl p-12 text-center">
        <p className="text-slate-500 font-medium">
          Team management module coming soon.
        </p>
      </div>
    </div>
  );
}


================================================================================
File: frontend-next/src/app/globals.css
Size: 262 B
================================================================================

/* src/app/globals.css */
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #0f172a;
}

body {
  color: var(--foreground);
  background: var(--background);
  font-feature-settings: 'rlig' 1, 'calt' 1;
}


================================================================================
File: frontend-next/src/app/layout.tsx
Size: 675 B
================================================================================

// src/app/layout.tsx
import { Inter } from 'next/font/google';
import './globals.css';
import { Toaster } from 'sonner';

// English: Loading the Inter font for the entire application
const inter = Inter({ subsets: ['latin'] });

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        {/* English: This is the main injection point for all pages and nested layouts */}
        {children}

        {/* English: Global toast notifications for the login and server responses */}
        <Toaster position="top-right" richColors />
      </body>
    </html>
  );
}


================================================================================
File: frontend-next/src/components/layout/Sidebar.tsx
Size: 1.3 kB
================================================================================

'use client';

import { LayoutDashboard, Users, FolderKanban, Settings } from 'lucide-react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';

export const Sidebar = () => {
  const pathname = usePathname();

  const menuItems = [
    { icon: LayoutDashboard, label: 'Dashboard', href: '/dashboard' },
    { icon: Users, label: 'Teams', href: '/dashboard/teams' },
    { icon: FolderKanban, label: 'Projects', href: '/dashboard/projects' },
    { icon: Settings, label: 'Settings', href: '/dashboard/settings' },
  ];

  return (
    <nav className="space-y-1">
      {menuItems.map((item) => {
        const isActive = pathname === item.href;
        return (
          <Link
            key={item.label}
            href={item.href}
            className={`flex items-center space-x-3 p-3 rounded-lg transition-all duration-200 ${
              isActive
                ? 'bg-blue-50 text-blue-700 shadow-sm'
                : 'text-slate-600 hover:bg-slate-50 hover:text-slate-900'
            }`}
          >
            <item.icon size={20} strokeWidth={isActive ? 2.5 : 2} />
            <span className={`font-medium ${isActive ? 'text-blue-700' : ''}`}>
              {item.label}
            </span>
          </Link>
        );
      })}
    </nav>
  );
};


================================================================================
File: frontend-next/src/components/layout/UserNav.tsx
Size: 1.33 kB
================================================================================

'use client';

import { Avatar, AvatarFallback } from '@/components/ui/avatar';
import { useAuthStore } from '@/store/useAuthStore';
import { LogOut } from 'lucide-react';

export function UserNav() {
  const { user, logout } = useAuthStore();

  if (!user) return null;

  const initials = user.name?.substring(0, 2).toUpperCase() || 'AD';

  return (
    <div className="flex flex-col gap-4">
      <div className="flex items-center gap-3 p-2">
        <Avatar className="h-10 w-10 border-2 border-white shadow-sm">
          <AvatarFallback className="bg-blue-600 text-white font-bold text-xs">
            {initials}
          </AvatarFallback>
        </Avatar>
        <div className="flex flex-col overflow-hidden">
          <p className="text-sm font-bold text-slate-900 truncate">
            {user.name}
          </p>
          <p className="text-xs text-slate-500 truncate">{user.email}</p>
        </div>
      </div>

      <button
        onClick={() => logout()}
        className="flex items-center space-x-2 w-full p-2.5 text-red-600 hover:bg-red-50 rounded-lg transition-colors group"
      >
        <LogOut
          size={18}
          className="group-hover:translate-x-1 transition-transform"
        />
        <span className="text-sm font-semibold">Sign Out</span>
      </button>
    </div>
  );
}


================================================================================
File: frontend-next/src/components/ui/avatar.tsx
Size: 2.91 kB
================================================================================

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  size = "default",
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root> & {
  size?: "default" | "sm" | "lg"
}) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      data-size={size}
      className={cn(
        "group/avatar relative flex size-8 shrink-0 overflow-hidden rounded-full select-none data-[size=lg]:size-10 data-[size=sm]:size-6",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted text-muted-foreground flex size-full items-center justify-center rounded-full text-sm group-data-[size=sm]/avatar:text-xs",
        className
      )}
      {...props}
    />
  )
}

function AvatarBadge({ className, ...props }: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="avatar-badge"
      className={cn(
        "bg-primary text-primary-foreground ring-background absolute right-0 bottom-0 z-10 inline-flex items-center justify-center rounded-full ring-2 select-none",
        "group-data-[size=sm]/avatar:size-2 group-data-[size=sm]/avatar:[&>svg]:hidden",
        "group-data-[size=default]/avatar:size-2.5 group-data-[size=default]/avatar:[&>svg]:size-2",
        "group-data-[size=lg]/avatar:size-3 group-data-[size=lg]/avatar:[&>svg]:size-2",
        className
      )}
      {...props}
    />
  )
}

function AvatarGroup({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="avatar-group"
      className={cn(
        "*:data-[slot=avatar]:ring-background group/avatar-group flex -space-x-2 *:data-[slot=avatar]:ring-2",
        className
      )}
      {...props}
    />
  )
}

function AvatarGroupCount({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="avatar-group-count"
      className={cn(
        "bg-muted text-muted-foreground ring-background relative flex size-8 shrink-0 items-center justify-center rounded-full text-sm ring-2 group-has-data-[size=lg]/avatar-group:size-10 group-has-data-[size=sm]/avatar-group:size-6 [&>svg]:size-4 group-has-data-[size=lg]/avatar-group:[&>svg]:size-5 group-has-data-[size=sm]/avatar-group:[&>svg]:size-3",
        className
      )}
      {...props}
    />
  )
}

export {
  Avatar,
  AvatarImage,
  AvatarFallback,
  AvatarBadge,
  AvatarGroup,
  AvatarGroupCount,
}


================================================================================
File: frontend-next/src/components/ui/button.tsx
Size: 2.4 kB
================================================================================

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-white hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        xs: "h-6 gap-1 rounded-md px-2 text-xs has-[>svg]:px-1.5 [&_svg:not([class*='size-'])]:size-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
        "icon-xs": "size-6 rounded-md [&_svg:not([class*='size-'])]:size-3",
        "icon-sm": "size-8",
        "icon-lg": "size-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant = "default",
  size = "default",
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      data-variant={variant}
      data-size={size}
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }


================================================================================
File: frontend-next/src/components/ui/dropdown-menu.tsx
Size: 8.42 kB
================================================================================

"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 max-h-(--radix-dropdown-menu-content-available-height) min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/20 data-[variant=destructive]:focus:text-destructive data-[variant=destructive]:*:[svg]:!text-destructive [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] origin-(--radix-dropdown-menu-content-transform-origin) overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}


================================================================================
File: frontend-next/src/components/ui/input.tsx
Size: 962 B
================================================================================

import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }


================================================================================
File: frontend-next/src/components/ui/separator.tsx
Size: 685 B
================================================================================

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }


================================================================================
File: frontend-next/src/core/schemas/auth.schema.ts
Size: 707 B
================================================================================

import { z } from 'zod';

export const loginSchema = z.object({
  email: z.string().email('Invalid email address'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

export const signupSchema = z
  .object({
    name: z.string().min(2, 'Name is too short'),
    email: z.string().email('Invalid email address'),
    password: z.string().min(8, 'Password must be at least 8 characters'),
    confirmPassword: z.string(),
  })
  .refine((data) => data.password === data.confirmPassword, {
    message: "Passwords don't match",
    path: ['confirmPassword'],
  });

export type LoginFormData = z.infer<typeof loginSchema>;
export type SignupFormData = z.infer<typeof signupSchema>;


================================================================================
File: frontend-next/src/lib/axios.ts
Size: 455 B
================================================================================

import axios from 'axios';
import Cookies from 'js-cookie';

const api = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api/v1',
  withCredentials: true,
  headers: {
    'Content-Type': 'application/json',
  },
});

api.interceptors.request.use((config) => {
  const token = Cookies.get('auth_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default api;


================================================================================
File: frontend-next/src/lib/utils.ts
Size: 283 B
================================================================================

import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

/**
 * English: Utility to merge Tailwind classes.
 * This is what @/components/ui/avatar.tsx is looking for.
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}


================================================================================
File: frontend-next/src/proxy.ts
Size: 1.05 kB
================================================================================

// src/proxy.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

/**
 * English: Next.js 16 Proxy function.
 * This handles route protection by checking the 'refresh_token' cookie.
 */
export function proxy(request: NextRequest) {
  // English: We use 'refresh_token' because that is what your Safari logs showed
  const token = request.cookies.get('refresh_token')?.value;
  const { pathname } = request.nextUrl;

  // English: If no token exists and user tries to enter dashboard, send them to login
  if (!token && pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/auth/login', request.url));
  }

  // English: If token exists and user tries to enter auth pages, send them to dashboard
  if (token && pathname.startsWith('/auth')) {
    return NextResponse.redirect(new URL('/dashboard', request.url));
  }

  return NextResponse.next();
}

// English: Configuration to match specific routes
export const config = {
  matcher: ['/dashboard/:path*', '/auth/:path*'],
};


================================================================================
File: frontend-next/src/store/useAuthStore.ts
Size: 1.39 kB
================================================================================

import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import Cookies from 'js-cookie';

interface User {
  id: string;
  email: string;
  name: string;
  role: string;
}

interface AuthState {
  user: User | null;
  isAuthenticated: boolean;
  setAuth: (user: User, token: string) => void;
  logout: () => void;
}

// English: Using persist middleware to keep user data after page reload
export const useAuthStore = create<AuthState>()(
  persist(
    (set) => ({
      user: null,
      // English: Check for refresh_token to match our proxy.ts logic
      isAuthenticated: !!Cookies.get('refresh_token'),
      setAuth: (user, token) => {
        // English: Although the server sets refresh_token via HttpOnly,
        // we store the access_token for client-side API calls.
        Cookies.set('access_token', token, {
          expires: 7,
          secure: process.env.NODE_ENV === 'production',
          sameSite: 'strict',
        });
        set({ user, isAuthenticated: true });
      },
      logout: () => {
        // English: Clear all possible tokens and redirect
        Cookies.remove('access_token');
        Cookies.remove('refresh_token');
        set({ user: null, isAuthenticated: false });
        window.location.href = '/auth/login';
      },
    }),
    {
      name: 'auth-storage', // English: Key for localStorage
    },
  ),
);


================================================================================
File: frontend-next/tsconfig.json
Size: 688 B
================================================================================

{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "noEmit": true,
    "incremental": true,
    "module": "esnext",
    "esModuleInterop": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "next-env.d.ts",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": ["node_modules"]
}


================================================================================
File: package.json
Size: 119 B
================================================================================

{
  "dependencies": {
    "@hookform/resolvers": "^5.2.2",
    "react-hook-form": "^7.71.1",
    "zod": "^4.3.6"
  }
}


================================================================================
File: prisma/migrations/20260114223603_init/migration.sql
Size: 4.39 kB
================================================================================

-- CreateEnum
CREATE TYPE "Role" AS ENUM ('USER', 'MANAGER', 'ADMIN');

-- CreateEnum
CREATE TYPE "InvitationStatus" AS ENUM ('PENDING', 'ACCEPTED', 'REJECTED', 'EXPIRED');

-- CreateEnum
CREATE TYPE "TaskStatus" AS ENUM ('TODO', 'IN_PROGRESS', 'DONE');

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "name" TEXT,
    "role" "Role" NOT NULL DEFAULT 'USER',
    "refresh_token_hash" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Team" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Team_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "TeamMember" (
    "id" SERIAL NOT NULL,
    "role" TEXT NOT NULL,
    "userId" INTEGER NOT NULL,
    "teamId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "TeamMember_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Project" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "teamId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Project_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Task" (
    "id" SERIAL NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT,
    "status" "TaskStatus" NOT NULL DEFAULT 'TODO',
    "dueDate" TIMESTAMP(3),
    "projectId" INTEGER NOT NULL,
    "assigneeId" INTEGER,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "deletedAt" TIMESTAMP(3),

    CONSTRAINT "Task_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Attachment" (
    "id" SERIAL NOT NULL,
    "filename" TEXT NOT NULL,
    "url" TEXT NOT NULL,
    "mimetype" TEXT NOT NULL,
    "size" INTEGER NOT NULL,
    "taskId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Attachment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Invitation" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "token" TEXT NOT NULL,
    "status" "InvitationStatus" NOT NULL DEFAULT 'PENDING',
    "expiresAt" TIMESTAMP(3) NOT NULL,
    "inviterId" INTEGER NOT NULL,
    "teamId" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Invitation_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "TeamMember_userId_teamId_key" ON "TeamMember"("userId", "teamId");

-- CreateIndex
CREATE UNIQUE INDEX "Invitation_token_key" ON "Invitation"("token");

-- AddForeignKey
ALTER TABLE "TeamMember" ADD CONSTRAINT "TeamMember_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "TeamMember" ADD CONSTRAINT "TeamMember_teamId_fkey" FOREIGN KEY ("teamId") REFERENCES "Team"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Project" ADD CONSTRAINT "Project_teamId_fkey" FOREIGN KEY ("teamId") REFERENCES "Team"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_projectId_fkey" FOREIGN KEY ("projectId") REFERENCES "Project"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Task" ADD CONSTRAINT "Task_assigneeId_fkey" FOREIGN KEY ("assigneeId") REFERENCES "User"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Attachment" ADD CONSTRAINT "Attachment_taskId_fkey" FOREIGN KEY ("taskId") REFERENCES "Task"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Invitation" ADD CONSTRAINT "Invitation_inviterId_fkey" FOREIGN KEY ("inviterId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Invitation" ADD CONSTRAINT "Invitation_teamId_fkey" FOREIGN KEY ("teamId") REFERENCES "Team"("id") ON DELETE CASCADE ON UPDATE CASCADE;


================================================================================
File: prisma/migrations/20260114230215_refactor_team_roles/migration.sql
Size: 356 B
================================================================================

/*
  Warnings:

  - The `role` column on the `TeamMember` table would be dropped and recreated. This will lead to data loss if there is data in the column.

*/
-- CreateEnum
CREATE TYPE "TeamRole" AS ENUM ('OWNER', 'MEMBER', 'VIEWER');

-- AlterTable
ALTER TABLE "TeamMember" DROP COLUMN "role",
ADD COLUMN     "role" "TeamRole" NOT NULL DEFAULT 'MEMBER';


================================================================================
File: prisma/migrations/migration_lock.toml
Size: 126 B
================================================================================

# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"

================================================================================
File: prisma/schema.prisma
Size: 3.68 kB
================================================================================

// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS (Business Logic) ---
enum Role {
  USER
  MANAGER
  ADMIN
}

enum TeamRole {
  OWNER
  MEMBER
  VIEWER
}

enum InvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
  EXPIRED
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  DONE
}

// --- MODELS ---

model User {
  id               Int           @id @default(autoincrement())
  email            String        @unique
  password         String
  name             String?
  role             Role          @default(USER)
  
  refreshTokenHash String?       @map("refresh_token_hash")

  // Relations
  teams           TeamMember[]
  assignedTasks   Task[]       @relation("TaskAssignee")
  invitationsSent Invitation[] @relation("Inviter")
  
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt
  deletedAt       DateTime?    // Audit: Soft Delete field
}

model Team {
  id          Int          @id @default(autoincrement())
  name        String
  members     TeamMember[]
  projects    Project[]
  invitations Invitation[]

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  deletedAt   DateTime?    // Audit: Soft Delete field
}

model TeamMember {
  id        Int      @id @default(autoincrement())
  role      TeamRole @default(MEMBER)
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId    Int
  team      Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, teamId])
}

model Project {
  id          Int      @id @default(autoincrement())
  name        String
  description String?  
  teamId      Int
  team        Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  tasks       Task[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  deletedAt   DateTime? // Audit: Soft Delete field
}

model Task {
  id          Int          @id @default(autoincrement())
  title       String
  description String?
  status      TaskStatus   @default(TODO)
  dueDate     DateTime?
  
  projectId   Int
  project     Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  
  assigneeId  Int?
  assignee    User?        @relation("TaskAssignee", fields: [assigneeId], references: [id])

  attachments Attachment[]

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  deletedAt   DateTime?    // Audit: Soft Delete field
}

model Attachment {
  id        Int      @id @default(autoincrement())
  filename  String   
  url       String   
  mimetype  String   
  size      Int      
  
  taskId    Int
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt   // Added: For consistency
  deletedAt DateTime?              // Added: Fixes the 500 error and enables Soft Delete
}

model Invitation {
  id         Int              @id @default(autoincrement())
  email      String           
  token      String           @unique
  status     InvitationStatus @default(PENDING)
  expiresAt  DateTime
  
  inviterId  Int
  inviter    User             @relation("Inviter", fields: [inviterId], references: [id], onDelete: Cascade)
  
  teamId     Int
  team       Team             @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt  DateTime         @default(now())
  updatedAt  DateTime         @updatedAt
}

================================================================================
File: prisma/seed.ts
Size: 1.97 kB
================================================================================

// prisma/seed.ts
import { PrismaClient, Role, TaskStatus, TeamRole } from '@prisma/client';
import * as argon2 from 'argon2';

const prisma = new PrismaClient();

async function main() {
  console.log('--- Starting Seeding Process ---');
  // English: Hashing the default password for the admin user
  const password = await argon2.hash('password123');

  // 1. Create or Update Admin User
  // English: The email is admin@test.com, not admin@demo.local
  const admin = await prisma.user.upsert({
    where: { email: 'admin@test.com' },
    update: { password },
    create: {
      email: 'admin@test.com',
      name: 'Admin User',
      password,
      role: Role.ADMIN,
    },
  });

  // 2. Create Team
  // English: Check if team exists to avoid unique constraint errors during re-seeding
  const existingTeam = await prisma.team.findFirst({
    where: { name: 'Development Team' },
  });

  if (!existingTeam) {
    const team = await prisma.team.create({
      data: {
        name: 'Development Team',
        members: {
          create: {
            userId: admin.id,
            role: TeamRole.OWNER,
          },
        },
      },
    });

    // 3. Create Project with Tasks
    await prisma.project.create({
      data: {
        name: 'Platform Rebuild',
        teamId: team.id,
        tasks: {
          create: [
            { title: 'Database Schema', status: TaskStatus.DONE },
            { title: 'API Implementation', status: TaskStatus.IN_PROGRESS },
            {
              title: 'Legacy Migration',
              status: TaskStatus.TODO,
              dueDate: new Date('2025-01-01'),
            },
          ],
        },
      },
    });
  }

  console.log('--- Seed Success ---');
  console.log({
    admin: admin.email,
    password_plain: 'password123',
  });
}

main()
  .catch((e) => {
    console.error('Error during seeding:', e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });


================================================================================
File: test/auth.e2e-spec.ts
Size: 2.97 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import request from 'supertest';
import cookieParser from 'cookie-parser';
import { AppModule } from './../src/app.module';
import { PrismaService } from './../src/prisma/prisma.service';

describe('AuthController (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;

  const testUser = {
    email: `e2e-auth-${Date.now()}@productivity.com`,
    password: 'password123',
    name: 'Nikolas Tesla',
  };

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();

    app.useGlobalPipes(
      new ValidationPipe({
        whitelist: true,
        transform: true,
        forbidNonWhitelisted: true,
      }),
    );
    app.use(cookieParser());

    await app.init();
    prisma = app.get<PrismaService>(PrismaService);
  });

  afterAll(async () => {
    await prisma.user.deleteMany({
      where: { email: testUser.email },
    });
    await prisma.$disconnect();
    await app.close();
  });

  describe('Authentication Flow', () => {
    it('/auth/signup (POST) - Success with RegisterDto', async () => {
      const response = await request(app.getHttpServer())
        .post('/auth/signup')
        .send({
          email: testUser.email,
          password: testUser.password,
          name: testUser.name,
        })
        .expect(201);

      expect(response.body).toHaveProperty('access_token');

      // English: Safe way to check cookies without TS errors
      const cookies = response.get('Set-Cookie');
      expect(cookies).toBeDefined();
      if (cookies) {
        expect(cookies[0]).toContain('refresh_token');
      }
    });

    it('/auth/signin (POST) - Success with LoginDto', async () => {
      const response = await request(app.getHttpServer())
        .post('/auth/signin')
        .send({
          email: testUser.email,
          password: testUser.password,
        })
        .expect(200);

      expect(response.body).toHaveProperty('access_token');
      expect(response.get('Set-Cookie')).toBeDefined();
    });

    it('/auth/logout (POST) - Success', async () => {
      const loginRes = await request(app.getHttpServer())
        .post('/auth/signin')
        .send({
          email: testUser.email,
          password: testUser.password,
        });

      const at = loginRes.body.access_token;

      return request(app.getHttpServer())
        .post('/auth/logout')
        .set('Authorization', `Bearer ${at}`)
        .expect(200);
    });

    it('/auth/signup (POST) - Should fail if name is missing', async () => {
      return request(app.getHttpServer())
        .post('/auth/signup')
        .send({
          email: 'noname@test.com',
          password: 'password123',
        })
        .expect(400);
    });
  });
});


================================================================================
File: test/invitations.e2e-spec.ts
Size: 3.21 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import request from 'supertest';
import { AppModule } from './../src/app.module';
import { PrismaService } from './../src/prisma/prisma.service';

describe('Invitations (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let ownerToken: string;
  let guestToken: string;
  let teamId: number;
  let invitationToken: string;

  const ownerUser = {
    email: 'owner@test.com',
    password: 'password123',
    name: 'Owner',
  };
  const guestUser = {
    email: 'guest@test.com',
    password: 'password123',
    name: 'Guest',
  };

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(new ValidationPipe());
    await app.init();
    prisma = app.get<PrismaService>(PrismaService);

    // 1. Create Owner and Team
    await request(app.getHttpServer()).post('/auth/signup').send(ownerUser);
    const loginOwner = await request(app.getHttpServer())
      .post('/auth/signin')
      .send(ownerUser);
    ownerToken = loginOwner.body.access_token;

    const teamRes = await request(app.getHttpServer())
      .post('/teams')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ name: 'E2E Team' });
    teamId = teamRes.body.id;

    // 2. Create Guest User
    await request(app.getHttpServer()).post('/auth/signup').send(guestUser);
    const loginGuest = await request(app.getHttpServer())
      .post('/auth/signin')
      .send(guestUser);
    guestToken = loginGuest.body.access_token;
  });

  afterAll(async () => {
    await prisma.user.deleteMany({
      where: { email: { in: [ownerUser.email, guestUser.email] } },
    });
    await prisma.team.deleteMany({ where: { name: 'E2E Team' } });
    await app.close();
  });

  it('POST /invitations/team/:id/send - Should send invitation', async () => {
    const res = await request(app.getHttpServer())
      .post(`/invitations/team/${teamId}/send`)
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ email: guestUser.email, role: 'MEMBER' })
      .expect(201);

    const inv = await prisma.invitation.findFirst({
      where: { email: guestUser.email },
    });
    invitationToken = inv!.token;
  });

  it('POST /invitations/accept - Should fail if email mismatch', async () => {
    // Attempting to accept guest's invitation with owner's account
    await request(app.getHttpServer())
      .post('/invitations/accept')
      .set('Authorization', `Bearer ${ownerToken}`)
      .send({ token: invitationToken })
      .expect(403);
  });

  it('POST /invitations/accept - Should join team successfully', async () => {
    await request(app.getHttpServer())
      .post('/invitations/accept')
      .set('Authorization', `Bearer ${guestToken}`)
      .send({ token: invitationToken })
      .expect(201);

    // Verify membership
    const member = await prisma.teamMember.findFirst({
      where: { teamId, user: { email: guestUser.email } },
    });
    expect(member).toBeDefined();
  });
});


================================================================================
File: test/jest-e2e.json
Size: 183 B
================================================================================

{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}


================================================================================
File: test/tasks.e2e-spec.ts
Size: 3.77 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import request from 'supertest';
import cookieParser from 'cookie-parser';
import { AppModule } from './../src/app.module';
import { PrismaService } from './../src/prisma/prisma.service';

describe('Tasks (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let accessToken: string;
  let userId: number;
  let projectId: number;

  const testUser = {
    email: `tasks-e2e-${Date.now()}@test.com`,
    password: 'password123',
    name: 'Task Tester',
  };

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(
      new ValidationPipe({ whitelist: true, transform: true }),
    );
    app.use(cookieParser());
    await app.init();
    prisma = app.get<PrismaService>(PrismaService);

    // --- SETUP: Create User, Team and Project ---
    // 1. Signup & Signin
    await request(app.getHttpServer()).post('/auth/signup').send(testUser);
    const loginRes = await request(app.getHttpServer())
      .post('/auth/signin')
      .send({
        email: testUser.email,
        password: testUser.password,
      });
    accessToken = loginRes.body.access_token;

    const user = await prisma.user.findUnique({
      where: { email: testUser.email },
    });
    userId = user!.id;

    // 2. Create Team
    const team = await prisma.team.create({
      data: {
        name: 'E2E Team',
        members: { create: { userId, role: 'OWNER' } },
      },
    });

    // 3. Create Project
    const project = await prisma.project.create({
      data: {
        name: 'E2E Project',
        teamId: team.id,
      },
    });
    projectId = project.id;
  });

  afterAll(async () => {
    // English: Cleanup database
    await prisma.user.deleteMany({ where: { email: testUser.email } });
    await prisma.team.deleteMany({ where: { name: 'E2E Team' } });
    await prisma.$disconnect();
    await app.close();
  });

  describe('/tasks', () => {
    it('POST /tasks - Should create a task', async () => {
      const createTaskDto = {
        title: 'Finish E2E Tests',
        description: 'Testing the task creation flow',
        projectId: projectId,
        status: 'TODO',
      };

      const response = await request(app.getHttpServer())
        .post('/tasks')
        .set('Authorization', `Bearer ${accessToken}`)
        .send(createTaskDto)
        .expect(201);

      expect(response.body).toHaveProperty('id');
      expect(response.body.title).toBe(createTaskDto.title);
    });

    it('GET /tasks/project/:id - Should return tasks for the project', async () => {
      const response = await request(app.getHttpServer())
        .get(`/tasks/project/${projectId}`)
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(200);

      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.length).toBeGreaterThan(0);
    });

    it('POST /tasks - Should fail if user is not in the team', async () => {
      // English: Create a project in a team where the user is NOT a member
      const otherTeam = await prisma.team.create({
        data: { name: 'Other Team' },
      });
      const otherProject = await prisma.project.create({
        data: { name: 'Unauthorized Project', teamId: otherTeam.id },
      });

      return request(app.getHttpServer())
        .post('/tasks')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({
          title: 'Hacker Task',
          projectId: otherProject.id,
        })
        .expect(403); // English: Forbidden
    });
  });
});


================================================================================
File: test/teams.e2e-spec.ts
Size: 2.48 kB
================================================================================

import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication, ValidationPipe } from '@nestjs/common';
import request from 'supertest';
import { AppModule } from './../src/app.module';
import { PrismaService } from './../src/prisma/prisma.service';

describe('Teams (e2e)', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let accessToken: string;
  let userId: number;

  const testUser = {
    email: `team-e2e-${Date.now()}@test.com`,
    password: 'password123',
    name: 'Team Manager',
  };

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(new ValidationPipe());
    await app.init();
    prisma = app.get<PrismaService>(PrismaService);

    // Setup: User & Auth
    await request(app.getHttpServer()).post('/auth/signup').send(testUser);
    const loginRes = await request(app.getHttpServer())
      .post('/auth/signin')
      .send({
        email: testUser.email,
        password: testUser.password,
      });
    accessToken = loginRes.body.access_token;

    const user = await prisma.user.findUnique({
      where: { email: testUser.email },
    });
    userId = user!.id;
  });

  afterAll(async () => {
    await prisma.user.deleteMany({ where: { email: testUser.email } });
    await prisma.$disconnect();
    await app.close();
  });

  describe('/teams', () => {
    it('POST /teams - Should create a team and assign user as OWNER', async () => {
      const response = await request(app.getHttpServer())
        .post('/teams')
        .set('Authorization', `Bearer ${accessToken}`)
        .send({ name: 'Alpha Team' })
        .expect(201);

      expect(response.body.name).toBe('Alpha Team');

      // English: Verify in DB that the membership was created correctly
      const membership = await prisma.teamMember.findFirst({
        where: { teamId: response.body.id, userId: userId },
      });
      expect(membership?.role).toBe('OWNER');
    });

    it('GET /teams - Should list user teams', async () => {
      const response = await request(app.getHttpServer())
        .get('/teams')
        .set('Authorization', `Bearer ${accessToken}`)
        .expect(200);

      expect(Array.isArray(response.body)).toBe(true);
      expect(response.body.some((t: any) => t.name === 'Alpha Team')).toBe(
        true,
      );
    });
  });
});

